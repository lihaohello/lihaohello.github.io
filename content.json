{"posts":[{"title":"AutoCAD实体操作触发的数据库事件","text":"花费一天时间，测试了AutoCAD中不同实体操作所触发的数据库事件，绘制本图与大家分享。 基于这幅图上的结论，可以构造一个巧妙算法，实现图纸修改记录器，一个非常棒的功能！","link":"/post/7164e23d4b42/"},{"title":"C++&#x2F;C#混合编程概览","text":"本系列文章的重点聚集在C+ +/CLI的以下三个方面： C+ +/CLI的基本语法，以及开发者理解它的一种感性视角。 C+ +/CLI封装.NET库供原生C+ +项目使用的实现步骤。 C+ +/CLI封装原生C+ +库供.NET项目使用的实现步骤。 混合编程的意义 C+ +简介 C+ +源代码编译后直接生成平台相关的二进制文件，运行效率极高；允许内存操作，适合底层系统开发；很多基础设施或大型软件都采用C+ +进行开发，这也促进了该语言的生态繁荣。 优点很多，但C+ +为人诟病的缺点也不少，例如：灵活高效的指针也带来了很多麻烦、语言越来越复杂等。 C#简介 C#逐渐替代C+ +成为微软阵营的顶流语言，其市场份额逐渐增大，并荣获了“TIOBE 2023年度编程语言”的称号，发展势头可见一斑！ 与Java类似，C#源代码编译之后也会生成中间语言，继而在.NET虚拟机上执行，虚拟机提供内存管理、垃圾回收的功能。 C#是纯粹的面向对象编程语言，学习曲线平缓；胜任多种类型的程序开发（如Web前后端、桌面程序等）；提供垃圾回收器机制，内存管理安全高效；有NuGet包管理器，海量开源库下载即用！ 且在工业软件二次开发领域，C#基本是一种标配，如AutoCAD、Revit等。 C#的不足之处在于：编写的程序非常容易被反编译成源代码，代码混淆器也很难根治这个问题；在计算密集型程序中，该语言还有待提升竞争力。 混合编程的使用场景 C+ +和C#是两种设计思想差异很大的编程语言，各有优劣，某些场景下需要将两者优势互补。 （1）跨语言复用程序库 采用C+ +进行项目开发时，如果需要用到既有C#类库，这时最好的方式是采用混合编程将既有C#类库封装起来，供C+ +项目调用；反之同理。 （2）软件保护 C#开发的软件保密性差，商业软件的核心技术模块最好采用C+ +编写，采用混合编程的方式封装该模块供C#主项目调用。 （3）软件整体性能提升 C#性能还无法匹敌C+ +，在C#项目中存在计算密集型的操作时，可使用C+ +编写核心计算模块，通过混合编程的方式嵌入C#主项目中，进而提升软件的整体性能。 混合编程的方法 C+ +和C#是微软生态的两个主力语言，Visual Studio对两者都有非常好的支持，微软也为C+ +/C#混合编程提供了非常强大的工具。 C+ +/CLI C+ +/CLI是一种C+ +变体语言，在支持原生C+ +语法的基础上，引入了一系列新的语法特性来支持托管代码的编写。C+ +/CLI项目可引入原生C+ +动态链接库或静态库，也支持引用C#类库，为实现跨语言调用程序库提供了语言基础。C+ +/CLI是最完美的C+ +/C#混合编程方案。 使用C+ +/CLI有三种模式：① 仅使用原生C+ +代码；② 仅使用托管代码；③ 使用原生C+ +和托管混合代码。当然，第③中模式才是重点，对于第①、②两种场景可直接构建原生的C+ +或C#项目。 P/Invoke P/Invoke是.NET提供的一种轻量机制，允许托管代码调用C/C+ +编写的原生代码；不支持C+ +调用C#代码。 当C#项目需要调用少量原生代码时，这种方式可以作为首选方案。 COM COM（Component Object Model）是微软早期提出的一种软件架构，允许软件组件在不同的编程语言之间进行交互。其编程较为复杂，且部署依赖Windows注册表；在某些方面，.NET框架已成为更好的技术方案。本文不做进一步介绍。 本系列文章的重点 本系列文章的重点聚集在C+ +/CLI的以下三个方面： （1）C+ +/CLI的基本语法，以及开发者理解它的一种感性视角。 （2）C+ +/CLI封装.NET库供原生C+ +项目调用的实现步骤。 （3）C+ +/CLI封装原生C+ +库供.NET项目调用的实现步骤。","link":"/post/c33982830a3c/"},{"title":"C++&#x2F;CLI基本语法和最佳实践","text":"详细剖析C+ +/CLI中的六大核心类型，总结C+ +/CLI实现跨语言调用既有库的最佳实践。 定位 C+ +/CLI是C+ +语言的一个变种，不仅支持原生C+ +的语法特性，也支持托管代码特性，这样就达到了在C+ +中调用C#库的目的。 结合原生C+ +的性能和C#的强大生态，C+ +/CLI可以高效开发独立运行的程序（控制台程序、窗体程序等），可惜的是，这并没有成为主流（大概是因为C+ +和C#两者的应用场景过于分明，实际并不需要大规模混合使用）！C+ +/CLI作为连接原生C+ +和C#的桥梁，通常被用来实现原生C+ +和C#既有程序库的跨语言调用。 所以，本文聚焦在C+ +/CLI的核心语法特性上，不会对其侧重于独立软件开发的语法特性进行过多介绍。 基本语法 “隙中窥月” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 使用原生C+ +标准库#include &lt;iostream&gt;#include &lt;vector&gt;// 通过命名空间引入.NET类型using namespace System;using namespace System::Collections::Generic;/// @brief 定义一个托管类ref class CLIPointClass {public: Double x; Double y; Double z; CLIPointClass(Double x, Double y, Double z) : x(x), y(y), z(z) { } void ShowPoint() { String^ info = String::Format(&quot;x={0}, y={1}, z={2}&quot;, x, y, z); Console::WriteLine(info); }};int main() { // C+ +动态数组 std::cout &lt;&lt; &quot;打印C+ +数据：&quot; &lt;&lt; std::endl; std::vector&lt;int&gt; vec{ 1,2,3,4,5,6,7,8,9,10 }; for each (int i in vec) std::cout &lt;&lt; i &lt;&lt; std::endl; // .NET动态数组 List&lt;Double&gt;^ datas = gcnew List&lt;Double&gt;(); datas-&gt;Add(0.1); datas-&gt;Add(0.2); datas-&gt;Add(0.3); datas-&gt;Add(0.4); datas-&gt;Add(0.5); Console::WriteLine(&quot;打印.NET数据：&quot;); for each (Double d in datas) { Console::WriteLine(d); } // 实例化自定义类CLIPointClass CLIPointClass^ p1 = gcnew CLIPointClass(100, 200, 300); p1-&gt;ShowPoint(); std::system(&quot;pause&quot;); return 0;} 以上代码中： （1）通过命名空间可引入C#库。 （2）定义托管类CLIPointClass，使用关键字ref class；实例化时使用gcnew表示创建托管类型，类型带上符号^。 （3）在主函数中可混合使用C+ +和C#的数据类型。 六种类和结构体类型详解 在C+ +/CLI中可以使用6种基本类和结构体类型： struct / class value struct / value class ref struct / ref class C#中struct / class的区别 （1）struct是值类型，class是引用类型。 （2）默认访问权限不一样，struct是public，class是private。 （3）struct不能有空参数的构造函数。 C+ +/CLI中struct / class的区别 与原生C+ +的结构体和类对应。 （1）默认访问权限不一样，struct是public，class是private。 （2）在C+ +11之后，struct也支持定义成员函数和继承。 （3）两者使用界限逐渐模糊，但是还是倾向于将struct视为一个数据容器。 C+ +/CLI中value struct / value class的区别 两者都是托管类型，基本等同；两者都不能有空参数的构造函数（与C#的struct特性对应）；等同于C#中的struct。 区别：默认访问权限不一样，struct是public，class是private。 C+ +/CLI中ref struct / ref class的区别 两者都是托管类型，基本等同；等同于C#中的class。 区别：默认访问权限不一样，struct是public，class是private。 六种类型的实例化、作为函数参数传递的方式 （1）struct / class struct和class的表现一样。同原生C+ +的struct / class，可声明到栈或堆上： 123456// 声明到栈上CppPointClass p1(5, 6);// 声明到堆上CppPointClass* p2 = new CppPointClass(7, 8);delete p4; 作为参数时，可以值传参、引用传参、指针传参，后两者可以对实例进行修改： 123456789101112131415161718// 值传参void Test01(CppPointClass p) { p.X = 100;}Test01(p1);// 引用传参void Test02(CppPointClass&amp; p) { p.X = 100;}Test02(p1);// 指针传参void Test03(CppPointClass* p) { p-&gt;X = 1000;}Test03(&amp;p1);Test03(p2); 如果想修改指针本身的值，需要采用指针的引用或指针的指针来传参： 12345678910111213// 指针的引用传参void Test04(CppPointClass*&amp; p) { // 修改指针本身的值 p = new CppPointClass(9999, 9999);}Test04(p2);// 指针的指针传参void Test05(CppPointClass** p) { // 修改指针本身的值 *p = new CppPointClass(9999, 9999);}Test05(&amp;p2); （2）value struct / value class value struct和value class的表现一样。可以声明为值类型，也可以声明为托管类型： 12345// 声明为值类型CLIValuePointClass p1(15, 16);// 声明为托管类型CLIValuePointClass^ p2 = gcnew CLIValuePointClass(11, 12) 同struct / class一样，可以使用值传参、引用传参、指针传参，引用传参时符号&amp;可以写成%： 1234567891011121314151617181920212223// 值传参void Test06(CLIValuePointClass p) { p.X = 99;}Test06(p1);// 引用传参1void Test07(CLIValuePointClass&amp; p) { p.X = 999;}Test07(p1);// 引用传参2void Test07_1(CLIValuePointClass% p) { p.X = 1000;}Test07_1(p1);// 指针传参void Test08(CLIValuePointClass* p) { p-&gt;X = 9999;}Test08(&amp;p1); 若接收托管类型参数，可以采用托管指针传参、托管指针引用传参，后者可以修改指针本身的值（类似C#中的ref参数）： 123456789101112// 托管指针传参void Test09(CLIValuePointClass^ p) { p-&gt;X = 99999;}Test09(p2);// 托管指针引用传参void Test10(CLIValuePointClass^% p) { // 修改指针本身的值 p = gcnew CLIValuePointClass(9999, 9999);}Test10(p2); （3）ref struct / ref class ref struct和ref class的表现一样。只能声明为托管类型： 1CLIRefPointClass^ p1 = gcnew CLIRefPointClass(11, 12); 可以采用托管指针传参、托管指针引用传参，后者可以修改指针本身的值（类似C#中的ref参数）： 123456789101112// 托管指针传参void Test11(CLIRefPointClass^ p) { p-&gt;X = 99999;}Test11(p1);// 托管指针引用传参void Test12(CLIRefPointClass^% p) { // 修改指针本身的值 p = gcnew CLIRefPointClass(9999, 9999);}Test11(p1); 六种类型中允许使用的数据类型 （1）struct / class 无法定义托管类型的字段。 方法的参数和返回值可以为托管类型。 （2）托管类型（value struct / value class 和 ref struct / ref class） 不能定义非托管类型的字段。 可以定义非托管类型的C+ +普通指针类型。 可以使用C+ +的基本数据类型，因为在这些类型可以和C#数据类型自动转换。 托管类型的方法参数和返回值可以为非托管类型，但是无法传参。 C+ +/CLI的其他托管特性 C+ +/CLI的其他诸多特性，例如enum class、interface class、property、委托、事件等，都是为扩展C+ +语言以支持更多的托管特性，如果采用C+ +/CLI来开发独立程序，使用的价值会比较大。 最佳实践 六种类型在原生C+ +或C#项目中呈现什么样子？ 当使用C+ +/CLI开发独立应用程序时，可以在程序逻辑中混用C+ +和C#的数据类型。 但是如果使用C+ +/CLI封装成DLL供原生C+ +或C#项目使用，这六种类型会呈现什么样子呢？ 原生C+ +项目的角度 站在原生C+ +项目的角度看六种类型，可以通过简单分析得到结论：原生C+ +项目要想引用C+ +/CLI的DLL，必须包含其头文件（指明了DLL导出的数据类型），如果这个头文件中包含任何托管代码特性，那么在原生C+ +项目中就会报错（理由很明晰：原生C+ +项目不支持托管代码特性）。 所以，使用C+ +/CLI封装程序库给原生C+ +项目使用时，头文件中不应该包含任何托管代码特性；但是在实现导出类成员方法或导出函数的具体逻辑时，可以使用托管代码。 C#项目的角度 站在C#项目的角度看六种类型，可通过代码实验得到结论： C+ +/CLI中的struct / class不可见，需在前面加上关键字public。在C#项目中，变成struct类型，其中的字段和方法不可访问； C+ +/CLI中的value struct / value class在C#项目中是struct类型。 C+ +/CLI中的ref struct / ref class在C#项目中是class类型。 C+ +/CLI中的四种托管类型中，可以声明非托管类型的指针成员变量，也可以定义参数和返回值均为非托管类型的方法，但是这些变量和方法无法在C#项目中直接被使用。 小结 六种类型 原生C+ +项目里 C#项目里 struct struct — class class — value struct — struct value class — struct ref struct — class ref class — class C+ +/CLI实现跨语言调用既有库的最佳实践 基于以上各种结论，在使用C+ +/CLI封装程序库给原生C+ +或C#项目使用时，注意如下： （1）封装程序库供C+ +使用： 在C+ +/CLI的头文件中不能包含任何托管代码特性。 封装C#代码给原生C+ +项目使用：在C+ +/CLI的导出类方法成员或导出函数内部使用C#的静态方法，或实例化C#类，从而使用既有C#的代码。 （2）封装程序库供C#使用： 凡是要暴露给C#项目的接口，统一使用托管类型。 托管类型的指针成员变量、参数或返回值为非托管类型的方法，只能充当函数逻辑实现的辅助，无法暴露给C#项目（避免出错，最好不要使用！） 封装原生C+ +代码给C#项目使用：可以定义一个C+ +类指针成员变量，作为原生C+ +代码的统一访问入口；（推荐方法） 封装原生C+ +代码给C#项目使用：可在C+ +/CLI的方法内部使用原生C+ +代码中的静态方法，或实例化原生C+ +代码里面的类，从而使用既有原生C+ +的代码。 以上就是使用C+ +/CLI实现程序库跨语言调用的最佳实践，后面两篇文章将以示例代码来展开说明。","link":"/post/d0fd12be7984/"},{"title":"C++&#x2F;CLI封装.NET库供原生C+ +项目调用","text":"以一个实例详细介绍C+ +/CLI封装.NET库供原生C+ +项目调用的步骤。 已得结论 在前面文章《C+ +/CLI基本语法和最佳实践》中，已经得到了以下重要结论： （1）struct / class 无法定义托管类型的字段。 方法的参数和返回值可以为托管类型。 （2）封装程序库供C+ +使用： 在C+ +/CLI的头文件中不能包含任何托管代码特性。 封装C#代码给原生C+ +项目使用：在C+ +/CLI的导出类方法成员或导出函数内部使用C#的静态方法，或实例化C#类，从而使用既有C#的代码。 下面以一个完整实例详细介绍如何使用C+ +/CLI封装.NET库供原生C+ +项目调用。 C#程序 以下C#代码定义了MyToolkits类，类中包含三个实例方法Add、Sum和IsStringRight，并定义了一个静态方法Fun01用于对Person数组进行json序列化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using Newtonsoft.Json;using System;using System.Collections.Generic;namespace CSLibrary { public class MyToolkits { public double Add(double a, double b) { return a + b; } public double Sum(List&lt;double&gt; list) { double sum = 0; foreach (var item in list) { sum += item; } return sum; } public bool IsStringRight(string text) { return text == &quot;LH&quot;; } /// &lt;summary&gt; /// 定义一个静态方法，进行Json序列化 /// &lt;/summary&gt; public static void Fun01() { List&lt;Person&gt; persons = new List&lt;Person&gt;(); persons.Add(new Person(&quot;li&quot;, &quot;hao&quot;, 30, &quot;lh@123.com&quot;)); persons.Add(new Person(&quot;li&quot;, &quot;hao&quot;, 30, &quot;lh@123.com&quot;)); persons.Add(new Person(&quot;li&quot;, &quot;hao&quot;, 30, &quot;lh@123.com&quot;)); string json = JsonConvert.SerializeObject(persons, Newtonsoft.Json.Formatting.Indented); Console.WriteLine(json); } } internal class Person { [JsonProperty(&quot;first_name&quot;)] public string FirstName { get; set; } [JsonProperty(&quot;last_name&quot;)] public string LastName { get; set; } public int Age { get; set; } public string Email { get; set; } public Person(string firstName, string lastName, int age, string email) { FirstName = firstName; LastName = lastName; Age = age; Email = email; } }} 使用C+ +/CLI封装 头文件 以下是C+ +/CLI封装库的头文件： 1234567891011121314151617181920#pragma once#include &lt;vector&gt;#include &lt;string&gt;#ifdef MYDLL_EXPORTS#define MYDLL_API __declspec(dllexport)#else#define MYDLL_API __declspec(dllimport)#endifnamespace lh2 { class MYDLL_API MyFuncs { public: double Add(double a, double b); double Sum(const std::vector&lt;double&gt;&amp; data); bool IsStringRight(std::string text); static void Fun01(); };} 结合前面的重要结论： 头文件中不包含任何的托管代码特性。 在Add、Sum、IsStringRight实例方法中，先实例化MyToolkits托管类，再调用托管类的方法进行计算。 C+ +/CLI中的double类型可以直接转换成Double托管类型，无需手动转换；原生C+ +的vector转托管List，采用遍历赋值的方式；原生C+ +的string转托管String类型，使用官方提供的转换函数。 这里的Fun01静态函数实现时，在方法体直接调用C#的静态函数。 源文件 以下是C+ +/CLI封装库的源文件： 123456789101112131415161718192021222324252627282930313233343536#include &lt;msclr/marshal_cppstd.h&gt;#include &quot;MyToolkitsWrapper.h&quot;using namespace CSLibrary;using namespace System;using namespace System::Collections::Generic;namespace lh2 { double MyFuncs::Add(double a, double b) { MyToolkits^ tool = gcnew MyToolkits(); return tool-&gt;Add(a, b); } double MyFuncs::Sum(const std::vector&lt;double&gt;&amp; data) { List&lt;Double&gt;^ list = gcnew List&lt;Double&gt;(); for each (double d in data) { list-&gt;Add(d); } MyToolkits^ tool = gcnew MyToolkits(); return tool-&gt;Sum(list); } bool MyFuncs::IsStringRight(std::string text) { MyToolkits^ tool = gcnew MyToolkits(); return tool-&gt;IsStringRight(msclr::interop::marshal_as&lt;String^&gt;(text)); } void MyFuncs::Fun01() { MyToolkits::Fun01(); }} 在C+ +项目中使用 123456789101112131415161718#include &quot;MyToolkitsWrapper.h&quot;#include &lt;iostream&gt;using namespace lh2;int main() { MyFuncs fun; std::cout &lt;&lt; fun.Add(12, 30) &lt;&lt; std::endl; std::vector&lt;double&gt; data{ 1,2,3,4,5,6,7,8,9,10 }; std::cout &lt;&lt; fun.Sum(data) &lt;&lt; std::endl; std::cout &lt;&lt; fun.IsStringRight(&quot;LH&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; fun.IsStringRight(&quot;LX&quot;) &lt;&lt; std::endl; fun.Fun01(); system(&quot;pause&quot;);}","link":"/post/d916595f4832/"},{"title":"C++&#x2F;CLI封装原生C+ +库供.NET项目调用","text":"以一个实例详细介绍C+ +/CLI封装原生C+ +库供.NET项目调用的步骤。 已得结论 在前面的文章《C+ +/CLI基本语法和最佳实践》中，已经得到了以下重要结论： （1）托管类型（value struct / value class 和 ref struct / ref class） 不能定义非托管类型的字段。 可以定义非托管类型的C+ +普通指针类型。 可以使用C+ +的基本数据类型，因为在这些类型可以和C#数据类型自动转换。 托管类型的方法参数和返回值可以为非托管类型，但是无法传参。 （2）封装程序库供C#使用： 凡是要暴露给C#项目的接口，统一使用托管类型。 托管类型的指针成员变量、参数或返回值为非托管类型的方法，只能充当函数逻辑实现的辅助，无法暴露给C#项目（避免出错，最好不要使用！） 封装原生C+ +代码给C#项目使用：可以定义一个C+ +类指针成员变量，作为原生C+ +代码的统一访问入口；（推荐方法） 封装原生C+ +代码给C#项目使用：可在C+ +/CLI的方法内部使用原生C+ +代码中的静态方法，或实例化原生C+ +代码里面的类，从而使用既有原生C+ +的代码。 下面以一个完整实例详细介绍如何使用C+ +/CLI封装原生C+ +库供.NET项目调用。 制作原生C+ +库 这里使用动态链接库，设置预编译器定义MYDLL_EXPORTS，确保预编译阶段MYDLL_EXPORTS宏被替换为__declspec(dllexport)。 头文件 123456789101112131415161718#pragma once#ifdef MYDLL_EXPORTS#define MYDLL_API __declspec(dllexport)#else#define MYDLL_API __declspec(dllimport)#endif#include &lt;vector&gt;#include &lt;string&gt;class MYDLL_API MyComputer{public: double Add(double a, double b); bool Divide(double a, double b, double&amp; res); double Sum(const std::vector&lt;double&gt;&amp; data); bool IsStringRight(std::string text);}; 注意：MYDLL_API必须放在class关键字后面，易错！ 源文件 123456789101112131415161718192021222324252627#include &quot;MyComputer.h&quot;double MyComputer::Add(double a, double b){ return a + b;}bool MyComputer::Divide(double a, double b, double&amp; res){ if (b == 0) return false; res = a / b; return true;}double MyComputer::Sum(const std::vector&lt;double&gt;&amp; data){ double res = 0.0; for (size_t i = 0; i &lt; data.size(); i++) res += data[i]; return res;}bool MyComputer::IsStringRight(std::string text){ return text == &quot;LH&quot;;} 使用C+ +/CLI封装 与原生C+ +项目一样，先设置附加包含路径（或者直接使用相对路径进行引用）、lib附加库目录以及lib输入库，确保项目可以找到原生C+ +的头文件和lib文件。 头文件 以下是C+ +/CLI封装库的头文件： 12345678910111213141516171819202122232425#pragma once#include &lt;msclr/marshal.h&gt;#include &lt;msclr/marshal_cppstd.h&gt;#include &quot;MyComputer.h&quot;using namespace System;using namespace System::Collections::Generic;namespace lh { public ref class MyComputerWrapper { private: MyComputer* pComputer; public: MyComputerWrapper(); ~MyComputerWrapper(); Double Add(Double a, Double b); Boolean Divide(Double a, Double b, Double% res); Double Sum(List&lt;Double&gt;^ data); Boolean IsStringRight(String^ text); };} 结合前面的重要结论： 暴露的接口只采用托管类型，不包含任何非托管类型成员，也没有参数或返回值为非托管类型的方法。 有一个MyComputer指针，MyComputer来自原生C+ +库，设置为私有，在构造函数中初始化，在析构函数中释放。在其他成员函数中通过该指针来访问原生C+ +代码。 这里的Double、Boolean也可以用double、bool替换，因为它们之间可以自动转换，但是不建议，大脑里的规则越少才越深刻！ 源文件 以下是C+ +/CLI封装库的源文件： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;vector&gt;#include &quot;MyComputerWrapper.h&quot;using namespace lh;MyComputerWrapper::MyComputerWrapper(){ pComputer = new MyComputer();}MyComputerWrapper::~MyComputerWrapper(){ delete pComputer;}Double MyComputerWrapper::Add(Double a, Double b){ return pComputer-&gt;Add(a, b);}Boolean MyComputerWrapper::Divide(Double a, Double b, Double% res){ double temp = 0.0; bool result = pComputer-&gt;Divide(a, b, temp); res = temp; return result;}Double MyComputerWrapper::Sum(List&lt;Double&gt;^ data){ std::vector&lt;double&gt; vec; for (size_t i = 0; i &lt; data-&gt;Count; i++) vec.push_back(data[i]); return pComputer-&gt;Sum(vec);}Boolean MyComputerWrapper::IsStringRight(String^ text){ return pComputer-&gt;IsStringRight(msclr::interop::marshal_as&lt;std::string&gt;(text)); return true;} 几点需要重点说明： Double是值类型，通过Double%实现引用传参，可以修改这个值，在C#项目里会变成ref double类型参数。 List^转std::vector类型，通过遍历赋值的方法实现。 方法的实现逻辑可以混用托管和非托管代码。 重点：数据转换 自动转换 以下类型可以相互转换： 在这个例子中，原生C+ +里面的类型是double，在C+ +/CLI方法实现中，我们直接把Double类型的值传给原生C+ +方法，不用转换。 msclr命名空间下的转换函数 注意：将#include&lt;msclr/marshal.h&gt;尽量前置，防止会引发IServiceProvider相关报错。 std::string &amp; System::String相互转换 marshal_cppstd.h头文件只提供std::string、std::wstring和System::String^相互转换的函数。 123456789101112131415161718#include &lt;msclr/marshal_cppstd.h&gt;#include &lt;iostream&gt;using namespace System;using namespace System::Collections::Generic;int main() { // std::string &amp; System::String相互转换 std::string str1 = &quot;Hello CLI&quot;; String^ str2 = msclr::interop::marshal_as&lt;String^&gt;(str1); Console::WriteLine(str2); String^ str3 = gcnew String(&quot;Hello C+ +&quot;); std::string str4 = msclr::interop::marshal_as&lt;std::string&gt;(str3); std::cout &lt;&lt; str4 &lt;&lt; std::endl; std::system(&quot;pause&quot;); return 0;} char* 转 System::String 1234567891011121314#include &lt;msclr/marshal.h&gt;#include &lt;iostream&gt;using namespace System;using namespace System::Collections::Generic;int main() { // char* 转 System::String char* str5 = &quot;Test String to Marshal&quot;; String^ str6 = msclr::interop::marshal_as&lt;String^&gt;(str5); Console::WriteLine(str6); std::system(&quot;pause&quot;); return 0;} 手动转换 例如C#中的List与C+ +中的vector，可以通过遍历赋值的方式相互转换。 枚举转换时，也用同样的方式。 在C#项目中使用 最后再C#项目中使用C+ +/CLR库，与引用普通C#库别无二致！ 12345678910111213141516171819202122using lh;using System;using System.Collections.Generic;namespace UseInCS { internal class Program { static void Main(string[] args) { MyComputerWrapper computer = new MyComputerWrapper(); Console.WriteLine(computer.Add(12, 34)); double res = 0; if (computer.Divide(24, 12, ref res)) Console.WriteLine(res); List&lt;double&gt; datas = new List&lt;double&gt;() { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; Console.WriteLine(computer.Sum(datas)); Console.WriteLine(computer.IsStringRight(&quot;LH&quot;)); } }}","link":"/post/64377354d42a/"},{"title":"CAD二开四境界","text":"CAD官方文档中有对CAD二次开发能力等级的描述，看看不同层级的技能要求，明确能力提升方向。 初级 理解图形数据库的整体结构 基本数据库读写操作 修改内置实体的属性 中级 自定义实体 反应器 高级 基于标准实体创建自定义实体 高级图形交互（AcEdJig等） 特级 深克隆 COM和ActiveX 创建对象属性管理器 体会 80%的业务需求只需要20%的技能，80%的技能只会用于20%的业务场景。 CAD二次开发技术多用于设计院数智化业务中，通常也只需要进行图形自动绘制，而不会使用自定义实体等高大上的技能，所以数据库读写依旧是学习CAD二次开发技术的重点。 但是更高级的技术可以在某些攻坚克难的业务场景中赋予我们更有效的手段，也是值得放到我们的工具箱中的。","link":"/post/18274d7d46a6/"},{"title":"C语言之语法歌","text":"整型浮点加数组，结构共用与枚举。 算术关系逻辑布，顺序条件共循环。 函数复用力无穷，指针威力与天通。 静态有无内外链，自动动态栈堆间。 字符流淌输入出，文件永存信息笺。 变量存储类别 变量存储类别关系大型程序的多文件组织问题，非常关键。 静态变量：存储在全局数据区，程序运行期间一直存在。包括外部链接静态变量（在所有函数外声明的文件变量，其他文件可通过extern引用）、内部链接静态变量（在所有函数外声明的文件变量，static修饰，不能被其他文件引用）、无链接静态变量（在函数内声明的局部变量，static修饰）。 自动变量：在函数内声明的局部变量，无static修饰，函数运行结束自动释放内存，又称为栈变量。 堆变量：采用malloc动态申请内存的变量，又称堆变量，需手动释放内存。 常数：包括字符串字面量、用const修饰的全局变量，存在与常量区。 字符串存储位置 变量存储类别关系大型程序的多文件组织问题，非常关键。 静态变量：存储在全局数据区，程序运行期间一直存在。包括外部链接静态变量（在所有函数外声明的文件变量，其他文件可通过extern引用）、内部链接静态变量（在所有函数外声明的文件变量，static修饰，不能被其他文件引用）、无链接静态变量（在函数内声明的局部变量，static修饰）。 自动变量：在函数内声明的局部变量，无static修饰，函数运行结束自动释放内存，又称为栈变量。 堆变量：采用malloc动态申请内存的变量，又称堆变量，需手动释放内存。 常数：包括字符串字面量、用const修饰的全局变量，存在与常量区。 指针与数组 指针名和数组名均返回数据首元素地址。 sizeof()用于数组名时，返回数组所有元素大小之和，应用于指针名，仅返回指针本身所占的内存大小。 指针加减一整数，表示移动了多少个变量所占内存大小的单元。","link":"/post/3848d891e790/"},{"title":"Inno Setup安装包制作","text":"Inno Setup与NSIS有异曲同工之妙，且拥有更加简明的语法，其基于Delphi的扩展开发语法也更加友好。 花些时间简单了解一下，作为技术储备不深入研究，实际工作中主打NSIS。 实际案例：打包AutoCAD插件系统 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596; 设置全局宏#define MyAppName &quot;XXX工具箱&quot;#define MyAppVersion &quot;1.0.0.1&quot;#define MyAppPublisher &quot;XXX公司&quot;; 设置注册表相关的全局宏#define MAINDLL2021 &quot;Toolkit_2021.dll&quot;#define MAINDLL2022 &quot;Toolkit_2022.dll&quot;#define regACAD2021 &quot;SOFTWARE\\Autodesk\\AutoCAD\\R24.0\\ACAD-4101:804&quot;#define regACAD2022 &quot;SOFTWARE\\Autodesk\\AutoCAD\\R24.1\\ACAD-5101:804&quot;[Setup]; 软件独一无二的IDAppId={{2ADB07D1-D7E2-42EC-92EE-A6868ED21060}; 软件名称AppName={#MyAppName}; 软件版本AppVersion={#MyAppVersion}; 安装包名称（不包含后缀名）OutputBaseFilename={#MyAppName}{#MyAppVersion}; 软件发布者AppPublisher={#MyAppPublisher}; 默认安装文件夹DefaultDirName={autopf}\\{#MyAppPublisher}\\{#MyAppName}; 启动菜单中所属文件夹DefaultGroupName={#MyAppName}; 设置是否允许用户不创建开始菜单AllowNoIcons=no; 设置压缩算法Compression=lzmaSolidCompression=yes; 设置只能在64位操作系统上运行ArchitecturesAllowed=x64; 设置安装路径在Program Files/ArchitecturesInstallIn64BitMode=x64; 设置安装界面的样式WizardStyle=modern; 设置安装界面的尺寸是否可调整WizardResizable=no; 设置安装界面尺寸缩放WizardSizePercent=100; 是否取消安装程序的欢迎界面DisableWelcomePage=no; 设置授权说明文件，注意该txt文件应该设置为Unicode BOM格式LicenseFile=license.txt; 防止通知打开多个安装进程SetupMutex=SetupMutex{#SetupSetting(&quot;AppId&quot;)}[Messages]; 同时打开多个安装进程时的提示SetupAppRunningError=安装程序正在执行中，不能同时执行多个！; 多语言设置，每一行代表可选的一种语言[Languages]Name: &quot;chinesesimplified&quot;; MessagesFile: &quot;compiler:Languages\\ChineseSimplified.isl&quot;; Name: &quot;en&quot;; MessagesFile: &quot;compiler:Default.isl&quot;; Name: &quot;Japanese&quot;; MessagesFile: &quot;compiler:Languages\\Japanese.isl&quot;; 安装文件到目标路径[Files]; 将Release下的所有文件和文件夹拷贝到安装路径，排除所有的pdb文件Source: &quot;D:\\PROJECTS\\安装包制作\\Toolkit\\Release\\*&quot;; Excludes: &quot;*.pdb&quot;; DestDir: &quot;{app}&quot;; Flags: ignoreversion recursesubdirs createallsubdirs; 图标设置[Icons]Name: &quot;{group}\\{cm:UninstallProgram,{#MyAppName}}&quot;; Filename: &quot;{uninstallexe}&quot;; 设置注册表[Registry]Root: HKCU; Subkey: &quot;{#regACAD2021}\\Applications\\{#MyAppName}&quot;; ValueType: string; ValueName: &quot;DESCRIPTION&quot;; ValueData: &quot;{#MyAppName}&quot;; Flags: uninsdeletekey; Check: ExistsAutoCAD(ExpandConstant('{#regACAD2021}'))Root: HKCU; Subkey: &quot;{#regACAD2021}\\Applications\\{#MyAppName}&quot;; ValueType: string; ValueName: &quot;LOADER&quot;; ValueData: &quot;{app}\\{#MAINDLL2021}&quot;; Flags: uninsdeletekey; Check: ExistsAutoCAD(ExpandConstant('{#regACAD2021}'))Root: HKCU; Subkey: &quot;{#regACAD2021}\\Applications\\{#MyAppName}&quot;; ValueType: dword; ValueName: &quot;LOADCTRLS&quot;; ValueData: 0x2; Flags: uninsdeletekey; Check: ExistsAutoCAD(ExpandConstant('{#regACAD2021}'))Root: HKCU; Subkey: &quot;{#regACAD2021}\\Applications\\{#MyAppName}&quot;; ValueType: dword; ValueName: &quot;MANAGED&quot;; ValueData: 0x1; Flags: uninsdeletekey; Check: ExistsAutoCAD(ExpandConstant('{#regACAD2021}'))Root: HKCU; Subkey: &quot;{#regACAD2022}\\Applications\\{#MyAppName}&quot;; ValueType: string; ValueName: &quot;DESCRIPTION&quot;; ValueData: &quot;{#MyAppName}&quot;; Flags: uninsdeletekey; Check: ExistsAutoCAD(ExpandConstant('{#regACAD2022}'))Root: HKCU; Subkey: &quot;{#regACAD2022}\\Applications\\{#MyAppName}&quot;; ValueType: string; ValueName: &quot;LOADER&quot;; ValueData: &quot;{app}\\{#MAINDLL2022}&quot;; Flags: uninsdeletekey; Check: ExistsAutoCAD(ExpandConstant('{#regACAD2022}'))Root: HKCU; Subkey: &quot;{#regACAD2022}\\Applications\\{#MyAppName}&quot;; ValueType: dword; ValueName: &quot;LOADCTRLS&quot;; ValueData: 0x2; Flags: uninsdeletekey; Check: ExistsAutoCAD(ExpandConstant('{#regACAD2022}'))Root: HKCU; Subkey: &quot;{#regACAD2022}\\Applications\\{#MyAppName}&quot;; ValueType: dword; ValueName: &quot;MANAGED&quot;; ValueData: 0x1; Flags: uninsdeletekey; Check: ExistsAutoCAD(ExpandConstant('{#regACAD2022}'))[dirs]; 设置文件夹权限为对所有用户完全开放权限Name: &quot;{app}&quot;; Permissions: everyone-full; 设置卸载时要删除的文件[UninstallDelete]Type: filesandordirs; Name:&quot;{app}&quot;[Code]; 检测是否存在某个版本的AutoCAD，借助注册表function ExistsAutoCAD(const Name:string): Boolean;var Res: String;begin Result := RegQueryStringValue(HKEY_LOCAL_MACHINE, Name,'AcadLocation', Res)end; 关键点总结 压缩方式：和NSIS一样可以设置 注册表操作（读、写、删）：读需要借助Delphi脚本实现，相比NSIS稍麻烦些 禁止启动多个安装进程：在这方面，Inno Setup有内置的控制参数，很方便 用户权限设置：在这方面，Inno Setup有内置的控制参数，很方便 读写xml文件：使用Delphi脚本实现，没有NSIS的插件方便","link":"/post/bdfcf540384d/"},{"title":"C语言之面向对象编程","text":"面向对象编程（OOP）四大特征：抽象、封装、继承、多态。主流的面向对象编程语言（如C++、Java、C#等）都有完善的面向对象实现机制。 C语言是面向过程编程语言，但可以通过结构体和指针实现类似的面向对象语言功能。所以，我更倾向于将其理解为一种编程思想，而不是面向对象编程语言仅有的特性。 本文基于一个实例，演示如何在C语言中实现多态。 定义函数指针 123456//基类函数成员typedef int (*fptrSet)(void *, int);typedef int (*fptrGet)(void *);typedef void (*fptrDisplay)(void *);//派生类新增函数成员typedef double (*fptrGetArea)(void *); 定义Shape基类 （1）定义“基类”，包含数据成员和函数成员，其中函数成员用函数指针定义。 （2）实现函数成员，定义为独立的函数，参数为结构体指针。 （3）实现“构造函数”，以参数形式将数据成员传递进来，直接用(2)中定义的函数给函数成员赋值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//定义基类Shapetypedef struct _shape{ //定义基类函数成员 struct { fptrSet setX; fptrGet getX; fptrSet setY; fptrGet getY; fptrDisplay display; }; //定义基类数据成员 int x; int y;} Shape;//函数成员的实现，独立函数还未绑定void shapeDisplay(Shape *shape){ printf(&quot;Shape\\n&quot;);}void shapeSetX(Shape *shape, int x){ shape-&gt;x = x;}void shapeSetY(Shape *shape, int y){ shape-&gt;y = y;}int shapeGetX(Shape *shape){ return shape-&gt;x;}int shapeGetY(Shape *shape){ return shape-&gt;y;}//定义构造函数：数据成员以参数传值，绑定独立的函数（为函数成员赋值）Shape *shapeConstructor(int x, int y){ Shape *shape = (Shape *)malloc(sizeof(Shape)); shape-&gt;x = x; shape-&gt;y = y; shape-&gt;display = shapeDisplay; shape-&gt;setX = shapeSetX; shape-&gt;setY = shapeSetY; shape-&gt;getX = shapeGetX; shape-&gt;getY = shapeGetY; return shape;} 定义Rectangle派生类 （1）基于C++及Java等面向对象程序设计语言中派生类的特性来实现该派生类。 （2）测试以下几点：派生类覆盖基类函数成员display；派生类新增数据成员width、height；派生类新增函数成员func1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //定义派生类typedef struct _rectangle{ //维护一个基类成员变量，必须为变量，不能用指针 Shape base; //派生类额外的函数成员 fptrGetArea func1; //派生类额外的数据成员 int width; int height;} Rectangle;//覆盖基类的dispalay方法void rectangleDisplay(Rectangle *rectangle){ printf(&quot;Rectangle\\n&quot;);}//实现派生类额外的函数成员double getArea(Rectangle *rectangle){ return rectangle-&gt;width * rectangle-&gt;height;}//定义构造函数Rectangle *rectangleConstructor(int width, int height, int x, int y){ Rectangle *rectangle = (Rectangle *)malloc(sizeof(Rectangle)); //初始化派生类中额外的成员 rectangle-&gt;width = width; rectangle-&gt;height = height; rectangle-&gt;func1 = getArea; //此处初始化新增函数成员 //初始化派生类中的基类变量 rectangle-&gt;base = (Shape){.x = x, .y = y, .display = rectangleDisplay, //此处覆盖基类函数成员 .setX = shapeSetX, .setY = shapeSetY, .getX = shapeGetX, .getY = shapeGetY}; return rectangle;} 测试 用基类指针指向派生类对象，调用基类方法时，可选择调用基类或派生类的方法实现，原理在于shapes[1]- &gt;display会访问实际函数地址，如果该函数已被派生类覆盖，则调用派生类的版本。 12345678910111213141516171819202122int main(){ //构造三个对象 Shape *shapes[3]; shapes[0] = shapeConstructor(0, 0);shapes[1] = rectangleConstructor(100, 200, 50, 50); shapes[2] = shapeConstructor(600, 600); //输出三个对象 for (int i = 0; i &lt; 3; i++) { shapes[i]-&gt;display(shapes[i]);printf(&quot;%d\\n&quot;, shapes[i]-&gt;getX(shapes[i])); } //输出shapes[1]中display函数的地址，两者相等，是该多态访问成功的基础 printf(&quot;%p\\n&quot;, ((Rectangle *)shapes[1])-&gt;base.display); printf(&quot;%p\\n&quot;, shapes[1]-&gt;display); //输出shapes[1]的面积，对于派生类特有的函数，应该转变为派生类指针后再访问 printf(&quot;area=%lf\\n&quot;, ((Rectangle *)shapes[1])-&gt;func1(shapes[1])); return 0;}","link":"/post/8acf80f1ddb3/"},{"title":"NSIS安装包制作","text":"安装包制作是软件发版的关键步骤，制作安装包的工具很多，总体分为两类：GUI工具（Advanced Installer等）、脚本工具（NSIS、Inno Setup等）。 本人在实际工作中深度使用NSIS，感受到了它的强大；同时，也喜欢Inno Setup更加简明的语法和基于Delphi的扩展开发。 实际案例：打包AutoCAD插件系统 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270# ========================= 宏定义 ========================= # 安装包相关信息宏定义!define PRODUCT_NAME &quot;XXX设计系统&quot;!define EXE_NAME &quot;${PRODUCT_NAME}.exe&quot;!define PRODUCT_VERSION &quot;1.0.0.0&quot;!define PRODUCT_PUBLISHER &quot;XXX公司&quot;!define PRODUCT_LEGAL &quot;&quot; # AutoCAD插件系统的主启动类库文件!define MAINDLL &quot;TsyShieldTunnelDesign.dll&quot;# 需要附带安装的安装包名称!define TOOLKIT_INSTALLER &quot;XXX工具箱.exe&quot; # 卸载注册表宏路径定义!define PRODUCT_UNINST_KEY &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${PRODUCT_NAME}&quot;!define PRODUCT_UNINST_ROOT_KEY &quot;HKLM&quot;# CAD注册表路径宏定义!define regACAD2020 &quot;SOFTWARE\\Autodesk\\AutoCAD\\R23.1\\ACAD-3001:804&quot;!define regACAD2021 &quot;SOFTWARE\\Autodesk\\AutoCAD\\R24.0\\ACAD-4101:804&quot;# ========================= 变量定义 =========================var PREVIOUS# ========================= 安装包版本信息 ========================= VIProductVersion &quot;${PRODUCT_VERSION}&quot; VIAddVersionKey &quot;ProductVersion&quot; &quot;${PRODUCT_VERSION}&quot; VIAddVersionKey &quot;ProductName&quot; &quot;${PRODUCT_NAME}&quot; VIAddVersionKey &quot;CompanyName&quot; &quot;${PRODUCT_PUBLISHER}&quot; VIAddVersionKey &quot;FileVersion&quot; &quot;${PRODUCT_VERSION}&quot; VIAddVersionKey &quot;InternalName&quot; &quot;${EXE_NAME}&quot; VIAddVersionKey &quot;FileDescription&quot; &quot;${PRODUCT_NAME}&quot; VIAddVersionKey &quot;LegalCopyright&quot; &quot;${PRODUCT_LEGAL}&quot;# ========================= NSIS属性 ========================= SetFont &quot;Segoe UI&quot; 9#SetCompressor lzmaSetCompressor zlibName &quot;${PRODUCT_NAME}V${PRODUCT_VERSION}&quot;OutFile &quot;${PRODUCT_NAME}V${PRODUCT_VERSION}.exe&quot;InstallDir &quot;$PROGRAMFILES64\\${PRODUCT_PUBLISHER}\\${PRODUCT_NAME}&quot;ShowInstDetails showShowUnInstDetails showRequestExecutionLevel admin# ========================= 外部插件及宏引用 =========================!include LogicLib.nsh!include &quot;x64.nsh&quot;!include &quot;Library.nsh&quot;!include &quot;WordFunc.nsh&quot;!define LIBRARY_X64!include &quot;MUI.nsh&quot;# ========================= MUI设置 ========================= ; MUI Settings!define MUI_ABORTWARNING!define MUI_ICON &quot;${NSISDIR}\\Contrib\\Graphics\\Icons\\modern-install.ico&quot;!define MUI_UNICON &quot;${NSISDIR}\\Contrib\\Graphics\\Icons\\modern-uninstall.ico&quot;;!define MUI_WELCOMEFINISHPAGE_BITMAP &quot;.\\background.bmp&quot;; Welcome page!define MUI_WELCOMEPAGE_TITLE &quot;欢迎使用《${PRODUCT_NAME}V${PRODUCT_VERSION}》安装向导&quot;!define MUI_WELCOMEPAGE_TEXT &quot;此程序将引导你安装《${PRODUCT_NAME}V${PRODUCT_VERSION}》。\\r\\n\\r\\n在安装前建议关闭AutoCAD，从而确保安装程序能够更新相关系统文件，避免在安装后需要重启AutoCAD。\\r\\n\\r\\n点击[下一步(N)]继续。&quot;!insertmacro MUI_PAGE_WELCOME; Directory page!define MUI_DIRECTORYPAGE_TEXT_TOP &quot;安装程序将把《${PRODUCT_NAME}V${PRODUCT_VERSION}》安装到以下目录。要安装到另一个目录，请点击[浏览(B)...]并选择其他的文件夹。$\\r$\\n$\\r$\\n点击[安装] 开始安装。&quot;!insertmacro MUI_PAGE_DIRECTORY; Instfiles page!insertmacro MUI_PAGE_INSTFILES; Finish page!insertmacro MUI_PAGE_FINISH; Uninstaller pages!insertmacro MUI_UNPAGE_INSTFILES; Language files!insertmacro MUI_LANGUAGE &quot;SimpChinese&quot;; Reserve files!insertmacro MUI_RESERVEFILE_INSTALLOPTIONS# ========================= 安装步骤 ========================= # 卸载已安装的软件Section &quot;&quot; SecUninstallPrevious ${If} $PREVIOUS == &quot;&quot; Goto Done ${EndIf} ;卸载已安装程序（和安装一起更安全） RMDir /r &quot;$INSTDIR&quot; RMDir /r &quot;$SMPROGRAMS\\城轨盾构法隧道设计系统&quot; setRegView 64 DeleteRegKey ${PRODUCT_UNINST_ROOT_KEY} &quot;${PRODUCT_UNINST_KEY}&quot; DeleteRegKey HKCU &quot;${regACAD2020}\\Applications\\${PRODUCT_NAME}&quot; DeleteRegKey HKCU &quot;${regACAD2021}\\Applications\\${PRODUCT_NAME}&quot; SetRegView Lastused Done: SectionEnd# .NET Framework版本检测和安装Section &quot;&quot; PRESEC ;检测.net framework版本 Call GetNetFrameworkVersion Pop $R1 ${VersionCompare} $R1 '4.8' $1 ${If} $1 == &quot;2&quot; ;安装net framework 4.8 SetDetailsPrint textonly SetDetailsPrint listonly SetOutPath &quot;$TEMP&quot; SetOverwrite on File &quot;.\\ndp48-x86-x64-allos-enu.exe&quot; ExecWait '$TEMP\\ndp48-x86-x64-allos-enu.exe /q /norestart /ChainingPackage FullX64Bootstrapper' $R1 Delete &quot;$TEMP\\ndp48-x86-x64-allos-enu.exe&quot; ${EndIf} SectionEnd# 安装附带的安装包Section &quot;&quot; TOOLKITINSTALLER SetDetailsPrint textonly SetDetailsPrint listonly SetOverwrite on ; 将附带安装包拷贝到临时文件夹 SetOutPath &quot;$INSTDIR\\TOOLKIT&quot; File &quot;.\\${TOOLKIT_INSTALLER}&quot; ; 安装 ExecWait '$INSTDIR\\TOOLKIT\\${TOOLKIT_INSTALLER} /S' ; 删除 Delete &quot;$INSTDIR\\TOOLKIT\\${TOOLKIT_INSTALLER}&quot;SectionEnd# 安装程序Section &quot;MainSection&quot; SEC01 SetOutPath &quot;$INSTDIR&quot; SetOverwrite ifnewer ; 复制文件Release下的所有文件，排除.pdb文件 File /r /x *.pdb &quot;..\\Release\\*.*&quot; ; 写注册表 setRegView 64 ; 为CAD2020安装（先检测是否有该注册项） ReadRegStr $1 HKLM &quot;${regACAD2020}&quot; &quot;AcadLocation&quot; ${If} $1 != &quot;&quot; WriteRegStr HKCU &quot;${regACAD2020}\\Applications\\${PRODUCT_NAME}&quot; &quot;DESCRIPTION&quot; &quot;${PRODUCT_NAME}&quot; WriteRegStr HKCU &quot;${regACAD2020}\\Applications\\${PRODUCT_NAME}&quot; &quot;LOADER&quot; &quot;$INSTDIR\\${MAINDLL}&quot; WriteRegDWORD HKCU &quot;${regACAD2020}\\Applications\\${PRODUCT_NAME}&quot; &quot;LOADCTRLS&quot; 0x2 WriteRegDWORD HKCU &quot;${regACAD2020}\\Applications\\${PRODUCT_NAME}&quot; &quot;MANAGED&quot; 0x1 ${EndIf} ; 为CAD2021安装 ReadRegStr $1 HKLM &quot;${regACAD2021}&quot; &quot;AcadLocation&quot; ${If} $1 != &quot;&quot; WriteRegStr HKCU &quot;${regACAD2021}\\Applications\\${PRODUCT_NAME}&quot; &quot;DESCRIPTION&quot; &quot;${PRODUCT_NAME}&quot; WriteRegStr HKCU &quot;${regACAD2021}\\Applications\\${PRODUCT_NAME}&quot; &quot;LOADER&quot; &quot;$INSTDIR\\${MAINDLL}&quot; WriteRegDWORD HKCU &quot;${regACAD2021}\\Applications\\${PRODUCT_NAME}&quot; &quot;LOADCTRLS&quot; 0x2 WriteRegDWORD HKCU &quot;${regACAD2021}\\Applications\\${PRODUCT_NAME}&quot; &quot;MANAGED&quot; 0x1 ${EndIf} SetRegView LastusedSectionEnd# 创建开始菜单项Section -AdditionalIcons SetOutPath $INSTDIR CreateDirectory &quot;$SMPROGRAMS\\XXX设计系统&quot; CreateShortCut &quot;$SMPROGRAMS\\XXX设计系统\\Uninstall.lnk&quot; &quot;$INSTDIR\\uninst.exe&quot;SectionEnd# 写入卸载相关的注册表信息Section -Post WriteUninstaller &quot;$INSTDIR\\uninst.exe&quot; setRegView 64 WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} &quot;${PRODUCT_UNINST_KEY}&quot; &quot;DisplayName&quot; &quot;$(^Name)&quot; WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} &quot;${PRODUCT_UNINST_KEY}&quot; &quot;UninstallString&quot; &quot;$INSTDIR\\uninst.exe&quot; WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} &quot;${PRODUCT_UNINST_KEY}&quot; &quot;DisplayIcon&quot; &quot;&quot; WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} &quot;${PRODUCT_UNINST_KEY}&quot; &quot;DisplayVersion&quot; &quot;${PRODUCT_VERSION}&quot; WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} &quot;${PRODUCT_UNINST_KEY}&quot; &quot;Publisher&quot; &quot;${PRODUCT_PUBLISHER}&quot; SetRegView Lastused ; 设置权限 ExecWait '&quot;$INSTDIR\\SetACL.exe&quot; -on &quot;$INSTDIR\\Plugins&quot; -ot file -actn ace -ace &quot;n:everyone;p:full&quot;'SectionEnd# 卸载程序Section Uninstall ; 删除文件 RMDir /r &quot;$INSTDIR&quot; ; 删除开始菜单项 RMDir /r &quot;$SMPROGRAMS\\XXX设计系统&quot; ; 删除注册表 setRegView 64 DeleteRegKey ${PRODUCT_UNINST_ROOT_KEY} &quot;${PRODUCT_UNINST_KEY}&quot; DeleteRegKey HKCU &quot;${regACAD2020}\\Applications\\${PRODUCT_NAME}&quot; DeleteRegKey HKCU &quot;${regACAD2021}\\Applications\\${PRODUCT_NAME}&quot; SetRegView Lastused ; 设置自动关闭卸载窗体 SetAutoClose trueSectionEnd# ========================= 回调函数 ========================= # 安装初始化事件处理Function .onInit ; 添加互斥体，防止同时创建多个安装进程 System::Call 'kernel32::CreateMutex(p 0, i 0, t &quot;myMutex&quot;) p .r1 ?e' Pop $R0 StrCmp $R0 0 +3 MessageBox MB_OK|MB_ICONEXCLAMATION &quot;安装程序已运行。&quot; Abort ; 检测是否已安装 setRegView 64 ReadRegStr $PREVIOUS ${PRODUCT_UNINST_ROOT_KEY} ${PRODUCT_UNINST_KEY} &quot;UninstallString&quot; SetRegView Lastused ${If} $PREVIOUS == &quot;&quot; Goto Done ${EndIf} ; 已安装，让用户选择是否覆盖安装，否则终止安装 MessageBox MB_YESNO &quot;检测已安装《${PRODUCT_NAME}》，是否覆盖安装？&quot; IDYES true IDNO false true: Goto Done false: Abort Done:FunctionEnd# 卸载初始化事件处理Function un.onInit MessageBox MB_ICONQUESTION|MB_YESNO|MB_DEFBUTTON2 &quot;是否确定彻底卸载 $(^Name)?&quot; IDYES +2 AbortFunctionEnd# 卸载完成事件处理Function un.onUninstSuccess HideWindow MessageBox MB_ICONINFORMATION|MB_OK &quot;$(^Name)已从您的电脑上彻底卸载。&quot;FunctionEnd# ========================= 用户函数 ========================= # .NET Framework版本检测Function GetNetFrameworkVersion Push $1 Push $0 ReadRegDWORD $0 HKLM &quot;SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v4\\Full&quot; &quot;Install&quot; ReadRegDWORD $1 HKLM &quot;SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v4\\Full&quot; &quot;Version&quot; StrCmp $0 1 KnowNetFrameworkVersion +1 ReadRegDWORD $0 HKLM &quot;SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v3.5&quot; &quot;Install&quot; ReadRegDWORD $1 HKLM &quot;SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v3.5&quot; &quot;Version&quot; StrCmp $0 1 KnowNetFrameworkVersion +1 ReadRegDWORD $0 HKLM &quot;SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v3.0\\Setup&quot; &quot;InstallSuccess&quot; ReadRegDWORD $1 HKLM &quot;SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v3.0\\Setup&quot; &quot;Version&quot; StrCmp $0 1 KnowNetFrameworkVersion +1 ReadRegDWORD $0 HKLM &quot;SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v2.0.50727&quot; &quot;Install&quot; ReadRegDWORD $1 HKLM &quot;SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v2.0.50727&quot; &quot;Version&quot; StrCmp $1 &quot;&quot; +1 +2 StrCpy $1 &quot;2.0.50727.832&quot; StrCmp $0 1 KnowNetFrameworkVersion +1 ReadRegDWORD $0 HKLM &quot;SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v1.1.4322&quot; &quot;Install&quot; ReadRegDWORD $1 HKLM &quot;SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v1.1.4322&quot; &quot;Version&quot; StrCmp $1 &quot;&quot; +1 +2 StrCpy $1 &quot;1.1.4322.573&quot; StrCmp $0 1 KnowNetFrameworkVersion +1 ReadRegDWORD $0 HKLM &quot;SOFTWARE\\Microsoft\\.NETFramework\\policy\\v1.0&quot; &quot;Install&quot; ReadRegDWORD $1 HKLM &quot;SOFTWARE\\Microsoft\\.NETFramework\\policy\\v1.0&quot; &quot;Version&quot; StrCmp $1 &quot;&quot; +1 +2 StrCpy $1 &quot;1.0.3705.0&quot; StrCmp $0 1 KnowNetFrameworkVersion +1 StrCpy $1 &quot;not .NetFramework&quot; KnowNetFrameworkVersion: Pop $0 Exch $1FunctionEnd 关键点总结 压缩方式：平衡速度和安装包体积 界面语言和字体设置 开始菜单和桌面快捷方式设置 检测是否已安装软件：通过读相关的注册表信息 注册表操作（读、写、删） .NET Framework版本检测 禁止启动多个安装进程：使用Windows API创建内核对象，实现进程之间的互斥 使用SetACL.exe设置目录的用户权限 补充 读写xml配置文件 在进行Revit插件安装时，需要配置addin配置文件，在其中写入真正的插件dll路径。addin文件本质上是一种xml文件，采用以下方式可以动态设置。 注意：需要事先部署好nsisXML插件。 12345678910; 复制xml配置文件SetOutPath &quot;${ADDINPATH}&quot;File &quot;..\\ShieldTunnelRevit\\TsyShieldTunnelRevitDesign.addin&quot;; 修改xml配置文件nsisXML::creatensisXML::load ${ADDINPATH}\\TsyShieldTunnelRevitDesign.addinnsisXML::select '/RevitAddIns/AddIn/Assembly'nsisXML::setText &quot;$INSTDIR\\TsyShieldTunnelRevitDesign.dll&quot; nsisXML::save &quot;${ADDINPATH}\\TsyShieldTunnelRevitDesign.addin&quot;nsisXML::release $0 权限修改 除了上文提到的SetACL.exe程序外，也可以使用AccessControl插件。","link":"/post/71c9ccfe4722/"},{"title":"P&#x2F;Invoke的基本使用","text":"简单介绍如何在C#项目中使用P/Invoke调用C/C+ +动态链接库中的函数，建议只用P/Invoke调用一些简单的C/C+ +函数，函数传参太过复杂时，采用C+ +/CLI的混合编程方式。 前面的文章《C+ +/CLI基本语法和最佳实践》提到，P/Invoke是.NET提供的一种轻量机制，允许托管代码调用C/C+ +编写的动态链接库，当C#项目需要调用少量原生代码时，这种方式非常方便。 C#和C+ +/CLI项目都可以使用P/Invoke机制，但本文只关注前者。 简单实例 封装C/C+ +函数库 12345678910111213141516171819202122232425262728#pragma once#include &lt;iostream&gt;// 自定义的函数使用extern &quot;C&quot;导出方式，方便P/Invoke能找到函数名extern &quot;C&quot; { // 无参数的函数 MYDLL_API void TestPInvoke1() { std::cout &lt;&lt; &quot;Hello PInvoke&quot; &lt;&lt; std::endl; } // 基本数据类型的参数 MYDLL_API double Add(double a, double b) { return a + b; } // 基本数据类型的数组 MYDLL_API double Sum(double data[], int num) { double sum = 0; for (size_t i = 0; i &lt; num; i++) sum += data[i]; return sum; } // 字符串参数 MYDLL_API void ShowText(const char* text) { std::cout &lt;&lt; text &lt;&lt; std::endl; }} 在C#中使用 12345678910111213141516171819202122232425262728293031323334353637using System;using System.Runtime.InteropServices;namespace TestPInvoke { internal class Program { [DllImport(&quot;D:\\\\Projects\\\\LearnCSharp\\\\out\\\\CPPDLL.dll&quot;, CallingConvention = CallingConvention.Cdecl, EntryPoint = &quot;TestPInvoke1&quot;, ExactSpelling = true)] private static extern void Test01(); [DllImport(&quot;user32.dll&quot;, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, SetLastError = true)] private static extern int MessageBox(IntPtr hWnd, string lpText, string lpCaption, uint uType); [DllImport(&quot;D:\\\\Projects\\\\LearnCSharp\\\\out\\\\CPPDLL.dll&quot;)] private static extern double Add(double a, double b); [DllImport(&quot;D:\\\\Projects\\\\LearnCSharp\\\\out\\\\CPPDLL.dll&quot;)] private static extern double Sum(double[] data, int num); [DllImport(&quot;D:\\\\Projects\\\\LearnCSharp\\\\out\\\\CPPDLL.dll&quot;)] private static extern void ShowText(string text); static void Main(string[] args) { Test01(); MessageBox(IntPtr.Zero, &quot;正在测试PInvoke&quot;, &quot;温馨提示&quot;, 1); Console.WriteLine(Add(10.0, 12.0)); double[] data = { 1, 2, 3, 4, 5 }; Console.WriteLine(Sum(data, 5)); ShowText(&quot;I am PInvoke&quot;); } }} 规则总结 参数类型转换 （1）基本的整数、浮点、布尔类型、字符串、基本数据类型的数组可以自动转换；P/Invoke的数据类型转换远不如C+ +/CLI的灵活，建议只用P/Invoke调用一些简单的C/C+ +函数。 （2）导出自定义函数时，使用extern &quot;C&quot;标识，PInvoke时使用CallingConvention.Cdecl导出规则。 （3）EntryPoint可以指定DLL中的函数名称；ExactSpelling默认为false，设置为true时，要求指定的函数名称与DLL中的名称完全一致，在某些情况下可能出错（指定extern &quot;C&quot;导出方式后DLL中的函数名称是一样的）。 （4）CallingConvention可以指定调用约定，默认为Winapi方式（同Stdcall方式），它们与Cdecl基本一致，但是对于Windows API的某些函数，会做微调，例如将MessageBox重编为MessageBoxA或MessageBoxW。如果将上例中的MessageBox调用改为如下代码，则会报错： 123456// 使用系统自带库函数[DllImport(&quot;user32.dll&quot;, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, SetLastError = true, ExactSpelling=true)]private static extern int MessageBox(IntPtr hWnd, string lpText, string lpCaption, uint uType); 原因是：设置ExactSpelling=true后，必须与DLL中的函数名称完全匹配才行，但是user32.dll中并没有MessageBox这个函数，将MessageBox改为MessageBoxW即可。","link":"/post/b67659789dc9/"},{"title":"WPF&#x2F;MVVM系列(1)——前言","text":"学习WPF之前，思考以下三个问题很有必要： 已有的Windows GUI开发技术有什么不足？ WPF解决了什么问题？ 学习WPF的目的是什么，最应该掌握哪些部分？ 已有的Windows GUI开发技术有什么不足？ Windows GUI开发技术先后经历了Windows API、MFC、VB和.NET等阶段，这些技术的抽象程度不断加深，极大促进了软件开发效率及可维护性的提升。.NET框架包含WinForms和WPF两种层次较高的GUI开发技术，作为WPF的对照，我们先考察WinForms的主要不足： WinForms的UI设计高度依赖设计器，开发者很难用代码设计复杂的UI。 WinForms缺乏数据绑定机制，开发者需要写大量代码来实现UI和数据的同步。 WinForms采用事件驱动模型，开发者一不小心就会把UI逻辑和业务逻辑混淆到一起。 WPF解决了什么问题？ WPF使用XAML语言进行UI设计，提供了绑定、资源、模板、动画等高级特性，表达能力很强。 WPF提供完善的数据绑定机制，很容易实现UI和数据的同步。 WPF采用数据驱动模型，原生支持MVVM模式，很容易实现UI和业务逻辑代码的分离，从而降低模块之间的耦合度，提升软件的可维护性。 学习WPF的目的是什么，最应该掌握哪些部分？ 我认为学习WPF的终极目的是：能熟练使用WPF的MVVM模式进行桌面应用开发，能保证代码的高度可维护性。 本系列文章不会介绍WPF控件的使用方法，使用控件是熟练度问题，门槛较低。 本系列文章聚焦在WPF的数据驱动模型和MVVM模式上，微软构建了一整套标准库用来实现这些高级特性，其中绑定、属性、事件和命令是当之无愧的核心，先对它们的来龙去脉进行介绍。 本系列文章最后将介绍如何使用原生库、三方库实现MVVM模式。","link":"/post/bac5ba7a9b06/"},{"title":"UML图","text":"UML图是软件设计的重要工具，本文对UML2.5中的图做一个整体介绍，并给出几种常用图的官方示例。 UML图的种类 最新版UML标准为2.5，发布于2015年6月，官网地址：https://www.uml-diagrams.org/。 注意：上图中蓝色标识的图不属于UML官方分类！ UML2.5图分为两大类（7+7），共计14种： 结构图（Structure Diagram）：描述系统的静态结构。 类图（Class Diagram）：表示类、接口以及其间的协作关系。 对象图（Object Diagram）：表示某一时刻一组对象及其间的关系。 包图（Package Diagram）：展现由模型分解而成的组织单元及其间的依赖关系。 组合结构图（Composite Structure Diagram）：描述一个分类器的内部结构，分类器与其他部分之间的交互端口，展示一组相互协作的实例如何完成特定任务。 组件图（Component Diagram）：展示一组构件之间的组织和依赖。 部署图（Deployment Diagram）：描述了系统内部的软件如何分布在不同的节点上。 轮廓图（Profile Diagram）：轮廓图提供了一种通用的扩展机制，用于为特定域和平台定制UML模型。 行为图（Behavior Diagram）：描述系统的动态行为。 用例图（UseCase Diagram）：展示参与者、用例及其间关系。 活动图（Activity Diagram）：展示了在系统内从一个活动到另一个活动的流程。 状态机图（State Machine Diagram）：对一个单独对象的行为建模，指明对象在它的整个生命周期里，响应不同事件时，执行相关事件的顺序。 交互图（Interaction Diagram）：对一个系统的动态方面进行建模。 序列图（Sequence Diagram）：是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。 通信图（Communication Diagram）：描述收发消息的对象之间的结构组织。 时序图（Timing Diagram）：适合实时和嵌入式系统建模的交互图，描述对象状态随着时间改变的情况。 交互概览图（Interaction Overview Diagram）：是活动图的变体，描述业务过程中的控制流概览。 类图 常见类型 领域模型图 实现类图 元素 类 接口 抽象类 … 六大关系 泛化（Generalization） 实现（Realization） 依赖（Dependency） 关联（Association） 聚合（Aggregation） 组合（Composition） 示例 组件图 组成部分 组件 供接口/需接口 端口 关系 用例图 两类 业务用例图（Business Use Case Diagram） 系统用例图（System Use Case Diagram） 四个要素 参与者 用例 关系 参与者 &amp; 参与者：泛化 参与者 &amp; 用例：关联 用例 &amp; 用例：包含、扩展、泛化 边界 示例 状态机图 要素 开始、结束 状态（简单状态、组合状态） 转换（事件和动作） 示例 活动图 两种使用方式 对工作流建模：常采用泳道将活动图中的活动状态分组 对操作建模 要素 开始点 结束点 活动状态 流程控制 分支：条件分支 合并：重新合并，不需要监护条件 分岔：一个控制流分成多个并发控制流 汇合：多条并发控制流合并 序列图 要素 角色 对象和生命线 活动条 消息：消息、异步消息、返回消息 交互框 alt：选择片段，if-else opt：可能发生或不发生 par：并行 loop：重复一定次数 … 示例","link":"/post/a77bec188872/"},{"title":"WPF&#x2F;MVVM系列(2)——绑定","text":"数据是任何软件系统的主角，软件系统的核心功能就是对数据进行存储、处理和展示。 数据存储形式主要包括数据库和文件，该过程相对独立，技术方案也相对成熟；相反，随着UI日趋复杂，数据处理和数据展示这两部分总是难解难分，开发者经常会将两者的代码混淆在一起，一不小心就会严重伤害到软件的可维护性。 WPF的数据绑定就是为了从本质上解决这个问题：将内存数据绑定到UI，内存数据和UI任何一方的变化都能马上同步到另一方，在XAML上实现UI编程，尽可能减少后端代码介入UI逻辑，让开发重心回归到数据处理上。 要素 数据绑定的几个基本要素是： （1）数据源和路径：将数据源的某一路径绑定到目标的某个属性上 （2）目标和属性 （3）绑定模式：Default（不同控件会有不同默认）、OneTime、OneWay（源→目标）、OneWayToSource（目标→源）、TwoWay（双向绑定） （4）触发数据源更新的方式：Default（不同控件会有不同默认）、Explicit、LostFocus（控件拾取焦点时）、PropertyChanged（属性变化时） 以下例子将tb1的Text绑定到tb2的Text上，双向绑定可互相更新，当tb2的Text发生变化时立即更新tb1的Text： 123456789101112131415&lt;Window x:Class=&quot;TestMvvm.Views.Test&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:TestMvvm.Views&quot; mc:Ignorable=&quot;d&quot; Title=&quot;Test&quot; SizeToContent=&quot;WidthAndHeight&quot;&gt; &lt;StackPanel Orientation=&quot;Vertical&quot;&gt; &lt;TextBox x:Name=&quot;tb1&quot; Width=&quot;100&quot; Height=&quot;20&quot; Margin=&quot;5&quot; Text=&quot;Hello Binding!&quot;/&gt; &lt;TextBox x:Name=&quot;tb2&quot; Width=&quot;100&quot; Height=&quot;20&quot; Margin=&quot;5&quot; Text=&quot;{Binding ElementName=tb1, Path=Text, Mode=TwoWay,UpdateSourceTrigger=PropertyChanged}&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 核心：数据源 WPF的绑定可谓”招式众多“，主要体现在数据源的种类上，能熟练使用各种数据源也是开发者经验丰富的体现。 WPF支持的数据源种类：控件、普通类实例、DataContext、ItemsSource、资源、LINQ、ADO数据对象（DataTable或DataView）、XML等。 实际使用较多的是：控件、普通类实例、DataContext、ItemsSource和资源。其中控件相对简单，本文主要对另外四种常用数据源做介绍，其余种类可先有印象，使用时再做研究。 普通类实例 在界面上放置一个TextBox（tbShow），用于显示内存数据；还有两个Button，点击btn1会更改内存数据，点击btn2会显示内存数据。 123456789101112131415&lt;Window x:Class=&quot;TestMvvm.Views.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:TestMvvm.Views&quot; mc:Ignorable=&quot;d&quot; x:Name=&quot;thisWin&quot; Title=&quot;用户登录&quot; Height=&quot;250&quot; Width=&quot;400&quot;&gt; &lt;StackPanel Orientation=&quot;Vertical&quot;&gt; &lt;TextBox x:Name=&quot;tbShow&quot;/&gt; &lt;Button x:Name=&quot;btn1&quot; Content=&quot;更改内存数据&quot; Click=&quot;btn1_Click&quot;/&gt; &lt;Button x:Name=&quot;btn2&quot; Content=&quot;显示内存数据&quot; Click=&quot;btn2_Click&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 在以上界面的后端代码中，定义了一个Student类，在窗体的构造函数中初始化一个Student实例student，并用代码将student的Name属性绑定到tb1的Text上，采用双向绑定。 12345678910111213141516171819202122232425262728293031323334353637using System.Windows;using System.Windows.Controls;using System.Windows.Data;namespace TestMvvm.Views { /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window { Student student { get; set; } public MainWindow() { InitializeComponent(); student = new Student(); student.Score = 90; Binding binding = new Binding(); binding.Source = student; binding.Path = new PropertyPath(&quot;Score&quot;); binding.Mode = BindingMode.TwoWay; binding.UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged; BindingOperations.SetBinding(this.tbShow, TextBox.TextProperty, binding); } private void btn1_Click(object sender, RoutedEventArgs e) { student.Score = 80; } private void btn2_Click(object sender, RoutedEventArgs e) { MessageBox.Show(student.Score.ToString()); } } public class Student { public int Score { get; set; } }} 启动程序，tb1中的文本如我们所料，是90： ①按照我们的直观理解，当点击btn1时，student的Score属性值变为80，tb1里的内容会更新，但实际出乎我们意料了，不变： ②手动修改tb1中的内容，内存数据会改变吗？会变： 根据①、②的测试，我们得出结论：将普通类实例作为源双向绑定到UI，UI变化可以同步至内存数据，但内存数据变化不会同步到UI。 解决方法：改造普通类，实现INotifyPropertyChanged接口，属性更新时手动触发属性修改事件处理器： 12345678910111213141516public class Student : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; private int score; public int Score { get { return score; } set { if (score != value) { score = value; if (PropertyChanged != null) { this.PropertyChanged.Invoke(this, new PropertyChangedEventArgs(&quot;Score&quot;)); } } } }} 我更喜欢的写法： 12345678910111213141516171819202122public class Student : NotifyPropertyChanged { private int score; public int Score { get { return score; } set { if (score != value) { score = value; RaisePropertyChanged(); } } }}// 辅助类，借助[CallerMemberName]特性从而避免手动传入属性名称public class NotifyPropertyChanged : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; public void RaisePropertyChanged([CallerMemberName] string propertyName = null) { if (PropertyChanged != null) { this.PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName)); } }} 总结：要想实现双向绑定双向同步，数据源必须实现INotifyPropertyChanged接口，并手动触发相应事件处理器。 为什么控件绑定不需要这样做呢？因为WPF控件本身已经做了这件事。 控件或其父控件的DataContext 基本使用 严格来说，DataContext只是一种绑定方式，而不是一种数据源。但因为这种方式太主流太重要了，所以单独分节来讲。 在上节中，采用代码进行数据绑定，实际上更好的方式是指定DataContext。 使用XAML进行绑定，不需要指定数据源。 123456789101112131415&lt;Window x:Class=&quot;TestMvvm.Views.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:TestMvvm.Views&quot; mc:Ignorable=&quot;d&quot; x:Name=&quot;thisWin&quot; Title=&quot;用户登录&quot; Height=&quot;250&quot; Width=&quot;400&quot;&gt; &lt;StackPanel Orientation=&quot;Vertical&quot;&gt; &lt;TextBox x:Name=&quot;tbShow&quot; Text=&quot;{Binding Path=Score,Mode=TwoWay,UpdateSourceTrigger=PropertyChanged}&quot;/&gt; &lt;Button x:Name=&quot;btn1&quot; Content=&quot;更改内存数据&quot; Click=&quot;btn1_Click&quot;/&gt; &lt;Button x:Name=&quot;btn2&quot; Content=&quot;显示内存数据&quot; Click=&quot;btn2_Click&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 在后端代码中使用DataContext指定数据源： 123456789Student student { get; set; }public MainWindow() { InitializeComponent(); student = new Student(); student.Score = 80; // 重点在这！ this.DataContext = student;} 关键：控件如何获取DataContext的值 当一个控件没有指定数据源时，默认会以DataContext属性值作为数据源。 如果该控件自身的DataContext属性没有被赋值，就会沿着控件树向上找父类们的DataContext属性值，一旦找到就以它作为数据源，不再继续向上搜索。 如果找到的DataContext中没有绑定的属性，那么绑定失败。 集合控件的ItemsSource 集合控件有ItemsSource属性，指定该属性后，在XAML中重定义数据模板时就可以用到数据绑定，该方式与上节的DataContext非常类似。 推荐使用ObservableCollection集合类型为ItemsSource赋值，这样的话，当集合元素增加或减少时，数据会自动同步到UI，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;Window x:Class=&quot;TestMvvm.Views.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:TestMvvm.Views&quot; xmlns:sys=&quot;clr-namespace:System;assembly=mscorlib&quot; mc:Ignorable=&quot;d&quot; x:Name=&quot;thisWin&quot; Title=&quot;用户登录&quot; Width=&quot;400&quot; SizeToContent=&quot;Height&quot;&gt; &lt;StackPanel x:Name=&quot;sp&quot; Orientation=&quot;Vertical&quot;&gt; &lt;TextBlock Text=&quot;Student ID:&quot; FontWeight=&quot;Bold&quot; Margin=&quot;5&quot;/&gt; &lt;TextBox x:Name=&quot;textBoxId&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;Student List:&quot; FontWeight=&quot;Bold&quot; Margin=&quot;5&quot;/&gt; &lt;ListBox x:Name=&quot;listBoxStudents&quot; Height=&quot;110&quot; Margin=&quot;5&quot;&gt; &lt;ListBox.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;{Binding Path=Id}&quot; Width=&quot;30&quot;/&gt; &lt;TextBlock Text=&quot;{Binding Path=Name}&quot; Width=&quot;60&quot;/&gt; &lt;TextBlock Text=&quot;{Binding Path=Age}&quot; Width=&quot;30&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListBox.ItemTemplate&gt; &lt;/ListBox&gt; &lt;Button x:Name=&quot;btnChangeData&quot; Click=&quot;btnChangeData_Click&quot; Margin=&quot;5&quot; Content=&quot;修改内存数据&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt;using System.Collections.ObjectModel;using System.Windows;namespace TestMvvm.Views { /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window { ObservableCollection&lt;Student&gt; students; public MainWindow() { InitializeComponent(); students = new ObservableCollection&lt;Student&gt;() { new Student() {Id=1,Name=&quot;Tim&quot;,Age=10}, new Student() {Id=2,Name=&quot;Tom&quot;,Age=20}, new Student(){Id=3,Name=&quot;Tony&quot;,Age=30}, }; this.listBoxStudents.ItemsSource = students; } private void btnChangeData_Click(object sender, RoutedEventArgs e) { students.Add(new Student() { Id = 1, Name = &quot;Lizi&quot;, Age = 10 }); students[0].Age = 50; } } public class Student { public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } }} 点击按钮修改内存数据后，会新增一条数据： 但是，会发现一个问题，点击按钮修改内存数据时，我们将第一个学生的你年龄修改为50，但是没有起作用，为什么呢？ 原因在于，虽然使用了ObservableCollection集合，但是只会通知集合元素数量变化的修改，修改元素的内容不会激发修改，这时同样需要改造Student类，当其属性修改时触发事件。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Student : NotifyPropertyChanged { private int id; public int Id { get { return id; } set { if (id != value) { id = value; RaisePropertyChanged(); } } } private string name; public string Name { get { return name; } set { if (name != value) { name = value; RaisePropertyChanged(); } } } private int age; public int Age { get { return age; } set { if (age != value) { age = value; RaisePropertyChanged(); } } }}public class NotifyPropertyChanged : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; public void RaisePropertyChanged([CallerMemberName] string propertyName = null) { if (PropertyChanged != null) { this.PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName)); } }} 总结：使用ItemsSource为集合控件指定数据源时，如果需要双向同步，要使用ObservableCollection集合作为数据源，且集合元素类型要实现INotifyPropertyChanged接口，并在属性变化时触发相应事件。 资源 如果定义了一个资源，且其类型与目标属性的类型一致，那么可以将该资源作为数据源指定给目标对象，不需要指定数据源属性名： 1234567891011121314151617181920212223&lt;Window x:Class=&quot;TestMvvm.Views.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:TestMvvm.Views&quot; xmlns:sys=&quot;clr-namespace:System;assembly=mscorlib&quot; mc:Ignorable=&quot;d&quot; x:Name=&quot;thisWin&quot; Title=&quot;用户登录&quot; Height=&quot;250&quot; Width=&quot;400&quot;&gt; &lt;Window.Resources&gt; &lt;sys:String x:Key=&quot;myString1&quot;&gt; 这是测试代码 &lt;/sys:String&gt; &lt;/Window.Resources&gt; &lt;StackPanel x:Name=&quot;sp&quot; Orientation=&quot;Vertical&quot;&gt; &lt;TextBox x:Name=&quot;tbShow&quot; Margin=&quot;5&quot; Text=&quot;{Binding Source={StaticResource myString1}, Path=.}&quot;/&gt; &lt;Button x:Name=&quot;btn1&quot; Margin=&quot;5&quot; Content=&quot;更改内存数据&quot; Click=&quot;btn1_Click&quot;/&gt; &lt;Button x:Name=&quot;btn2&quot; Margin=&quot;5&quot; Content=&quot;显示内存数据&quot; Click=&quot;btn2_Click&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 当界面控件较多，且不同控件的某些属性值一样时，可以将共同的属性值提取出来作为资源变量，方便后期统一修改。 数据校验 基本使用 可以把数据绑定看作连接两个岛屿的双向行车桥梁，数据如同商品一样在该通道上双向流通，这条通道上也设有关卡，可以对来往商品进行核检。 以上节最终的代码为基础，增加对Score的合法性验证，Score应在[0,100]之间。WPF的数据校验使用起来非常简单，主要分为两个步骤： （1）自定义校验规则，继承ValidationRule类，重载Validate方法 123456789public class ScoreValidateRule : ValidationRule { public override ValidationResult Validate(object value, CultureInfo cultureInfo) { int score = 0; if (int.TryParse(value.ToString(), out score)) if (score &lt; 0 || score &gt; 100) return new ValidationResult(false, &quot;分数非法&quot;); return new ValidationResult(true, null); }} （2）添加到绑定上，以下是XAML的写法 1234567891011&lt;StackPanel x:Name=&quot;sp&quot; Orientation=&quot;Vertical&quot;&gt; &lt;TextBox x:Name=&quot;tbShow&quot; Margin=&quot;5&quot; Validation.Error=&quot;tbShow_Error&quot;&gt; &lt;TextBox.Text&gt; &lt;Binding Path=&quot;Score&quot; Mode=&quot;TwoWay&quot; UpdateSourceTrigger=&quot;PropertyChanged&quot;&gt; &lt;Binding.ValidationRules&gt; &lt;local:ScoreValidateRule/&gt; &lt;/Binding.ValidationRules&gt; &lt;/Binding&gt; &lt;/TextBox.Text&gt; &lt;/TextBox&gt;&lt;/StackPanel&gt; 这时，如果在文本框里面输入非法值，文本框边缘颜色变红指示数据非法： 两个问题 虽然添加了数据验证规则，但经过测试，仍会发现两点不足： （1）点击“更改内存数据”按钮后，内存Score属性变为200，但不会有非法提示！ 想要改变目标属性有两种方法：①修改数据源数据；②用户直接修改界面目标的数据。WPF默认不会对第一种方式进行校核，所以会出现以上问题。 解决方法是：设置自定义校验规则类实例的ValidatesOnTargetUpdated为true。 1234567891011&lt;StackPanel x:Name=&quot;sp&quot; Orientation=&quot;Vertical&quot;&gt; &lt;TextBox x:Name=&quot;tbShow&quot; Margin=&quot;5&quot; Validation.Error=&quot;tbShow_Error&quot;&gt; &lt;TextBox.Text&gt; &lt;Binding Path=&quot;Score&quot; Mode=&quot;TwoWay&quot; UpdateSourceTrigger=&quot;PropertyChanged&quot;&gt; &lt;Binding.ValidationRules&gt; &lt;local:ScoreValidateRule ValidatesOnTargetUpdated=&quot;True&quot;/&gt; &lt;/Binding.ValidationRules&gt; &lt;/Binding&gt; &lt;/TextBox.Text&gt; &lt;/TextBox&gt;&lt;/StackPanel&gt; （2）数据非法时，只是边框颜色变红显示，能自定义非法数据出现时的响应吗？ 可以为绑定目标设置校验错误实践处理器，并设置绑定的NotifyOnValidationError属性为true。 1234567891011121314&lt;StackPanel x:Name=&quot;sp&quot; Orientation=&quot;Vertical&quot;&gt; &lt;TextBox x:Name=&quot;tbShow&quot; Margin=&quot;5&quot; Validation.Error=&quot;tbShow_Error&quot;&gt; &lt;TextBox.Text&gt; &lt;Binding Path=&quot;Score&quot; Mode=&quot;TwoWay&quot; UpdateSourceTrigger=&quot;PropertyChanged&quot; NotifyOnValidationError=&quot;True&quot;&gt; &lt;Binding.ValidationRules&gt; &lt;local:ScoreValidateRule ValidatesOnTargetUpdated=&quot;True&quot;/&gt; &lt;/Binding.ValidationRules&gt; &lt;/Binding&gt; &lt;/TextBox.Text&gt; &lt;/TextBox&gt;&lt;/StackPanel&gt;private void tbShow_Error(object sender, ValidationErrorEventArgs e) { MessageBox.Show(&quot;Error:&quot;);} 数据转换 某些情况下，数据源属性和目标属性的数据类型可能不一样，开发者希望数据转换能自动进行，这时就需要用到数据转换机制了。 以上节代码为例，我们希望UI文本框里显示分数的格式为”分数成绩为90，优秀！“，分数[0，60）为不及格，[60，85]为良好，[86，100]为优秀。 实现数据转换主要包括两个步骤： （1）自定义数据转换类 123456789101112131415161718public class ScoreConverter : IValueConverter { public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { int score = 0; if (int.TryParse(value.ToString(), out score)) { if (score &gt;= 0 &amp;&amp; score &lt;= 59) return $&quot;分数成绩为{score}，不合格！&quot;; else if (score &gt;= 60 &amp;&amp; score &lt;= 85) return $&quot;分数成绩为{score}，良好！&quot;; else return $&quot;分数成绩为{score}，优秀！&quot;; } return null; } public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) { throw new NotImplementedException(); }} （2）给Binding的Converter属性赋值 12345678910111213141516171819&lt;Window x:Class=&quot;TestMvvm.Views.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:TestMvvm.Views&quot; mc:Ignorable=&quot;d&quot; x:Name=&quot;thisWin&quot; Title=&quot;用户登录&quot; Height=&quot;250&quot; Width=&quot;400&quot;&gt; &lt;Window.Resources&gt; &lt;local:ScoreConverter x:Key=&quot;scoreConverter&quot;/&gt; &lt;/Window.Resources&gt; &lt;StackPanel x:Name=&quot;sp&quot; Orientation=&quot;Vertical&quot;&gt; &lt;TextBox x:Name=&quot;tbShow&quot; Margin=&quot;5&quot; Text=&quot;{Binding Path=Score,Mode=TwoWay,UpdateSourceTrigger=PropertyChanged,Converter={StaticResource ResourceKey=scoreConverter}}&quot;/&gt; &lt;Button x:Name=&quot;btn1&quot; Margin=&quot;5&quot; Content=&quot;更改内存数据&quot; Click=&quot;btn1_Click&quot;/&gt; &lt;Button x:Name=&quot;btn2&quot; Margin=&quot;5&quot; Content=&quot;显示内存数据&quot; Click=&quot;btn2_Click&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 这时，修改数据源的数据，界面显示的信息是经过转换之后的信息： 多路绑定 当一个UI控件的某个属性值同时由多个数据源的多个属性控制时，就需要用到多路绑定，且多路绑定必须与多路数据转换同时使用。 例如，界面上有两个TextBox和一个Button，我们希望两个TextBox里面都有值的时候才激活Button。 （1）定义数据转换器 1234567891011public class MyConverter : IMultiValueConverter { public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture) { if (!values.Cast&lt;string&gt;().Any(text =&gt; string.IsNullOrWhiteSpace(text))) return true; return false; } public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture) { throw new NotImplementedException(); }} （2）设置多路绑定 12345678910111213141516171819202122232425262728&lt;Window x:Class=&quot;TestMvvm.Views.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:TestMvvm.Views&quot; mc:Ignorable=&quot;d&quot; x:Name=&quot;thisWin&quot; Title=&quot;测试&quot; SizeToContent=&quot;WidthAndHeight&quot;&gt; &lt;Window.Resources&gt; &lt;local:MyConverter x:Key=&quot;myConverter&quot;/&gt; &lt;/Window.Resources&gt; &lt;StackPanel x:Name=&quot;sp&quot; Orientation=&quot;Vertical&quot;&gt; &lt;TextBox x:Name=&quot;tb1&quot; Width=&quot;150&quot; Height=&quot;20&quot; Margin=&quot;5&quot;/&gt; &lt;TextBox x:Name=&quot;tb2&quot; Width=&quot;150&quot; Height=&quot;20&quot; Margin=&quot;5&quot;/&gt; &lt;Button x:Name=&quot;btn1&quot; Width=&quot;150&quot; Height=&quot;20&quot; Margin=&quot;5&quot; Content=&quot;提交&quot;&gt; &lt;Button.IsEnabled&gt; &lt;MultiBinding Converter=&quot;{StaticResource myConverter}&quot; Mode=&quot;OneWay&quot;&gt; &lt;MultiBinding.Bindings&gt; &lt;Binding ElementName=&quot;tb1&quot; Path=&quot;Text&quot;/&gt; &lt;Binding ElementName=&quot;tb2&quot; Path=&quot;Text&quot;/&gt; &lt;/MultiBinding.Bindings&gt; &lt;/MultiBinding&gt; &lt;/Button.IsEnabled&gt; &lt;/Button&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 总结 （1）在实际项目中要善用WPF绑定，数据→UI的逻辑要尽可能通过数据绑定来实现，UI逻辑里不要有对数据处理的代码。 （2）数据绑定的重难点在于如何使用不同的数据源，在实际项目中要不断丰富自己的招式。 （3）数据校验和数据转换虽然是辅助工具，但对它们的熟练使用能极大增强数据绑定应对实际复杂问题的杀伤力。","link":"/post/aef0d2e71de3/"},{"title":"WPF&#x2F;MVVM系列(3)——属性","text":".NET中有三种属性：C#语言层面的普通属性（以下简称“C#常规属性”）、WPF依赖属性、WPF附加属性。 C#常规属性的缘由：封装是面向对象编程的一大特性，其表现形式就是类。类通常包含若干字段，这些字段一般不直接对外开发，而是通过GetXXX/SetXXX这对方法来间接访问，这样就可以进行数据合法性检测。C#语言非常人性化，将GetXXX/SetXXX这对方法抽象成一个新的语言特性——属性。 WPF依赖属性和附加属性，从语言语法角度来看没有额外创新，属于.NET标准库层面的进一步封装。 WPF依赖属性 作用 （1）解决存在大量类实例时C#属性内存使用过大的问题 由于属性显式或隐式地映射一个字段，当一个类中包含多个属性且在程序中大量实例化该类时，这些属性就会占据（类实例数量）x（属性内存消耗）的内存。 为了满足精细化UI控制要求，WPF的布局组件或控件属性众多，以上内存占用问题就相对突出，怎么解决呢？ WPF创造了依赖属性，依赖属性的特点是：一个类实例如果没有显式给依赖属性赋值，那么就是用全局默认值，这时不会占据内存；如果显式赋值了，就会另外存储。 （2）为WPF的高级特性（例如绑定）提供底层支持 设置绑定时，数据源种类很多，但是绑定目标必须继承自依赖对象（DependencyObject），且绑定属性通常是依赖属性。 使用 使用依赖属性很简单，新建类，继承DependentObject；在类中键入propdp，按两次tab按键，就会生成定义依赖属性的模板；设置属性类型（如下为string）、属性名（如下为Name）、补全typeof(Student)中的类名、补全默认值（如下为lh）。 使用C#属性对依赖属性进行包装，使用时与普通属性别无二致（记住这一点，使用它时大脑就会保持清醒）。 12345678910public class Student : DependencyObject { public string Name { get { return (string)GetValue(NameProperty); } set { SetValue(NameProperty, value); } } // Using a DependencyProperty as the backing store for Name. This enables animation, styling, binding, etc... public static readonly DependencyProperty NameProperty = DependencyProperty.Register(&quot;Name&quot;, typeof(string), typeof(Student), new PropertyMetadata(&quot;lh&quot;));} WPF附加属性 作用 通常有这样的需求：相同的一个类实例，在不同环境下可能有不同的语境属性，例如一个人在学校有“班级”属性，在公司有“职称”属性。 但不可能在定义“人”这个类时，一次性添加所有可能的属性；这时可以使用附加属性。 附加属性定义在环境类中（如上面的“学校”类或“公司”类），用环境类的静态方法设置属性值，传入“人”的类实例就可以。 使用 使用附加属性很简单，新建类，继承DependentObject；在类中键入propa，按两次tab按键，就会生成定义附加属性的模板；设置属性类型（如下为int）、属性名（如下为Grade）、补全typeof(School)中的类名、补全默认值（如下为1）。 会使用两个静态方法对获取和设置附加属性的操作进行包装，都需要传递一个依赖对象参数，最后使用依赖对象来直接调用GetValue/SetValue方法；而在依赖对象中，直接由this调用GetValue/SetValue方法，两者原理基本一致。 12345678910111213public class School : DependencyObject { public static int GetGrade(DependencyObject obj) { return (int)obj.GetValue(GradeProperty); } public static void SetGrade(DependencyObject obj, int value) { obj.SetValue(GradeProperty, value); } // Using a DependencyProperty as the backing store for Grade. This enables animation, styling, binding, etc... public static readonly DependencyProperty GradeProperty = DependencyProperty.RegisterAttached(&quot;Grade&quot;, typeof(int), typeof(School), new PropertyMetadata(1));} 总结 WPF的依赖属性和附加属性设计得相当巧妙（不愧是微软的大牛们，他们总能为软件世界贡献自己的无穷智慧），弥补了C#常规属性在某些场景下的不足；但在形式上又尽可能与C#常规属性保持一致！ 我认为，学习WPF的依赖属性和附加属性，明白它们的作用最为重要；其次，在使用和理解它们时，能够在大脑里化繁为简，这样就能游刃有余！ 至于源码，本人就不做深入探究了，呵呵！","link":"/post/f60d8be4dda4/"},{"title":"WPF&#x2F;MVVM系列(5)——命令","text":"学习WPF的命令机制，我认为最重要的是能够找到一种在MVVM模式中使用它的最佳工程实践方式。 绑定和命令是MVVM模式的核心，后面介绍MVVM模式基本是顺水推舟了。 与路由事件的关系 在深入了解WPF的命令之前，有必要澄清它和路由事件的关系： （1）路由事件提供了一种灵活的事件传递机制，主要用于处理界面状态的变化； （2）命令主要用于封装业务逻辑，从而保证代码复用性。 （3）路由事件和命令是出发点不同的两套机制，不是相互替换的关系。 （4）在大型软件系统中，通常需要同时使用路由事件和命令来协作完成某些复杂功能。 使用RoutedCommand 在WPF中，按钮控件有Command属性，设置这个属性就可以为按钮绑定命令。 一种方式是使用RoutedCommand类，这是标准库提供的实现了ICommand接口的命令类，但是它没有实现具体的CanExecute()和Executed()逻辑，需要通过命令关联的方式添加这两个逻辑。 （1）以下窗体中有一个按钮btn1和一个文本框tb1。当文本框内的内容为空时，按钮不可用；否则可用，且单击按钮时文本框里的内容会被清空： 123456789101112131415161718&lt;Window x:Class=&quot;TestMVVM01.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:TestMVVM01&quot; xmlns:sys=&quot;clr-namespace:System;assembly=mscorlib&quot; mc:Ignorable=&quot;d&quot; SizeToContent=&quot;WidthAndHeight&quot; Title=&quot;MainWindow&quot;&gt; &lt;StackPanel Orientation=&quot;Vertical&quot; x:Name=&quot;sp1&quot;&gt; &lt;StackPanel Orientation=&quot;Vertical&quot; x:Name=&quot;sp2&quot;&gt; &lt;Button x:Name=&quot;btn1&quot; Content=&quot;Send Command&quot; Margin=&quot;5&quot;/&gt; &lt;TextBox x:Name=&quot;tb1&quot; Margin=&quot;5,0&quot; Height=&quot;100&quot;/&gt; &lt;/StackPanel&gt; &lt;/StackPanel&gt;&lt;/Window&gt; （2）后台代码通过CommandBinding为该命令设置CanExecute()和Executed()逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445using System;using System.Windows;using System.Windows.Input;namespace TestMVVM01 { public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); // 初始化命令绑定 InitializeCommand(); } private RoutedCommand clearCmd = new RoutedCommand(&quot;Clear&quot;, typeof(MainWindow)); private void InitializeCommand() { this.clearCmd.InputGestures.Add(new KeyGesture(Key.C, ModifierKeys.Alt)); // 为按钮绑定命令 this.btn1.Command = clearCmd; this.btn1.CommandTarget = this.tb1; // 使用命令绑定指定CanExecute()和Executed()的具体逻辑 CommandBinding binding = new CommandBinding(); binding.Command = this.clearCmd; binding.CanExecute += new CanExecuteRoutedEventHandler(cb_CanExecute); binding.Executed += new ExecutedRoutedEventHandler(cb_Executed); // 将命令绑定添加到布局组件上 this.sp1.CommandBindings.Add(binding); } private void cb_Executed(object sender, ExecutedRoutedEventArgs e) { this.tb1.Clear(); e.Handled = true; } private void cb_CanExecute(object sender, CanExecuteRoutedEventArgs e) { if (String.IsNullOrEmpty(this.tb1.Text)) e.CanExecute = false; else e.CanExecute = true; e.Handled = true; } }} 当然，也可以在XAML中定义，以下使用WPF内置命令New，用户指定该命令的CanExecute()和Executed()逻辑。大多数内置命令是静态类的成员，需要实现个性化操作时通过传参实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;Window x:Class=&quot;TestMVVM01.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:TestMVVM01&quot; xmlns:sys=&quot;clr-namespace:System;assembly=mscorlib&quot; mc:Ignorable=&quot;d&quot; Height=&quot;240&quot; Width=&quot;360&quot; WindowStyle=&quot;ToolWindow&quot; Background=&quot;LightBlue&quot; Title=&quot;Command Parameter&quot;&gt; &lt;Grid Margin=&quot;6&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;24&quot;/&gt; &lt;RowDefinition Height=&quot;4&quot;/&gt; &lt;RowDefinition Height=&quot;24&quot;/&gt; &lt;RowDefinition Height=&quot;4&quot;/&gt; &lt;RowDefinition Height=&quot;24&quot;/&gt; &lt;RowDefinition Height=&quot;4&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;TextBlock Text=&quot;Name:&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Left&quot; Grid.Row=&quot;0&quot;/&gt; &lt;TextBox x:Name=&quot;nameTextBox&quot; Margin=&quot;60,0,0,0&quot; Grid.Row=&quot;0&quot;/&gt; &lt;Button Content=&quot;New Teacher&quot; Command=&quot;New&quot; CommandParameter=&quot;Teacher&quot; Grid.Row=&quot;2&quot;/&gt; &lt;Button Content=&quot;New Student&quot; Command=&quot;New&quot; CommandParameter=&quot;Student&quot; Grid.Row=&quot;4&quot;/&gt; &lt;ListBox x:Name=&quot;listBoxItems&quot; Grid.Row=&quot;6&quot;/&gt; &lt;/Grid&gt; &lt;Window.CommandBindings&gt; &lt;CommandBinding Command=&quot;New&quot; CanExecute=&quot;CommandBinding_CanExecute&quot; Executed=&quot;CommandBinding_Executed&quot;/&gt; &lt;/Window.CommandBindings&gt;&lt;/Window&gt;/// MainWindow.xaml 的交互逻辑/// &lt;/summary&gt;public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); } private void CommandBinding_CanExecute(object sender, CanExecuteRoutedEventArgs e) { if (string.IsNullOrEmpty(this.nameTextBox.Text)) e.CanExecute = false; else e.CanExecute = true; } private void CommandBinding_Executed(object sender, ExecutedRoutedEventArgs e) { string name = this.nameTextBox.Text; if (e.Parameter.ToString() == &quot;Teacher&quot;) this.listBoxItems.Items.Add($&quot;New Teacher: {name}, 学而不厌、诲人不倦。&quot;); if (e.Parameter.ToString() == &quot;Student&quot;) this.listBoxItems.Items.Add($&quot;New Student: {name}, 好好学习、天天向上。&quot;); }} 以上方式需要在代码中集中指定命令的CanExecute()和Executed()逻辑，每个命令不是相对独立的个体，与“高内聚”的软件设计思想有所违背，不是推荐用法。 较好的工程实践 回归命令机制的初衷，开发者不希望在窗体的事件处理函数中写业务逻辑，更倾向于将每个业务逻辑写成普通函数，然后包装成命令供界面使用。 那么，如何将业务处理逻辑包装成命令呢？我认为以下方式是比较好的工程做法。 （1）自定义以下命令类，通过构造函数传入实际的Execute()和CanExecute()执行逻辑，开发者可显式调用RaiseCanExecuteChange()函数，从而触发CanExecute()的执行来更新控件的可用状态（一般在窗体控件事件中触发）。 12345678910111213141516171819202122232425public class MyCommand : ICommand { private Action&lt;object&gt; execute; private Func&lt;object, bool&gt; canExecute; public MyCommand(Action&lt;object&gt; execute, Func&lt;object, bool&gt; canExecute = null) { this.execute = execute; this.canExecute = canExecute; } public event EventHandler CanExecuteChanged; public bool CanExecute(object parameter) { if (canExecute != null) return CanExecute(parameter); return true; } public void Execute(object parameter) { execute?.Invoke(parameter); } public void RaiseCanExecuteChange() { CanExecuteChanged?.Invoke(this, EventArgs.Empty); }} （2）在ViewModel类中定义命令，并包装成可读可写属性供界面绑定。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class TestViewModel : NotifyPropertyChanged { private MyCommand _command1; public MyCommand Command1 { get { return _command1; } set { _command1 = value; RaisePropertyChanged(); } } public TestViewModel() { _command1 = new MyCommand(ShowMessage, SetEnbale); } #region 业务处理逻辑，程序的核心 private void ShowMessage(object parameter) { var para = parameter as Window; if (para != null) MessageBox.Show($&quot;窗体宽度为：{para.Width}&quot;); } private bool SetEnbale(object parameter) { var para = parameter as Window; if (para != null &amp;&amp; para.Width &gt; 300) return true; return false; } #endregion}&lt;Window x:Class=&quot;TestMvvm.Views.Test&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:TestMvvm.Views&quot; mc:Ignorable=&quot;d&quot; x:Name=&quot;myWin&quot; SizeChanged=&quot;myWin_SizeChanged&quot; Title=&quot;Test&quot; SizeToContent=&quot;WidthAndHeight&quot;&gt; &lt;StackPanel Orientation=&quot;Vertical&quot;&gt; &lt;Button x:Name=&quot;btn1&quot; Content=&quot;按钮1&quot; Command=&quot;{Binding Command1}&quot; CommandParameter=&quot;{Binding ElementName=myWin}&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 以上代码有几个关键点： ① 给命令传参：在XAML中通过绑定将窗体作为参数传递给命令，CanExecute()和Execute()都能捕获这个参数。 ② 更新按钮的可用状态：本实例在窗体宽度大于300时设置按钮可见，点击按钮后消息框显示窗体的宽度。为了更新按钮状态，必须在窗体尺寸变化事件处理器中调用RaiseCanExecuteChange()函数来间接触发CanExecute()函数；不直接调用CanExecute()函数，是因为开发者没有办法显式向其传递参数。","link":"/post/e5f31a19ab87/"},{"title":"WPF&#x2F;MVVM系列(4)——事件","text":"学习WPF的路由事件，我认为最重要是以下两点： 相比传统的消息驱动和事件驱动模型，路由事件的优势是什么。 基于WPF的两种树形结构，直观理解路由事件的运行规律。 关于如何自定义路由事件以及附加事件，通常不是开发者的重点，如有必要可再深入探究。 消息驱动和事件驱动 消息驱动 Windows是消息驱动的操作系统，在Windows下进行GUI程序开发，最底层的方式就是Windows API。以下是一个窗口消息处理函数，整体是switch条件判断结构，不同的消息流向不同的分支被处理。 12345678910111213141516171819202122232425262728293031323334353637LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ switch (message) { case WM_COMMAND: { int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) { case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); } } break; case WM_PAINT: { PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... EndPaint(hWnd, &amp;ps); } break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); } return 0;} 注册窗体类时，将以上消息处理函数的地址赋值给窗体类的lpfnWndProc字段，就完成了消息处理函数的绑定。 1234567891011121314151617ATOM MyRegisterClass(HINSTANCE hInstance){ WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_PROJECT1)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_PROJECT1); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);} 事件驱动 基于消息驱动的GUI程序开发与底层Windows API打交道较多，开发门槛较高。微软采用面向对象的方式对其进一步封装，就得到了事件驱动模型，最为典型的就是WinForms技术。 （1）在WinFroms窗体上添加一个按钮“按钮1”： （2）双击界面设计器的按钮，跳转到按钮单击事件处理函数中： （3）界面设计器会自动把按钮单击事件处理函数绑定到按钮的单击事件上： 以上例子将事件处理函数（Form1的button1_Click函数）显式地绑定到按钮的单击事件上（button1.Click）。 总结一下事件驱动的关键特点：不管是窗体设计器自动绑定还是人为绑定，肯定存在“显式绑定”这一操作；且在绑定时，控件的事件、事件处理函数必须可见。 对于复杂软件系统而言，事件驱动的这一“显式绑定”要求会增加模块之间的耦合度，伤害到软件的可维护性，为此WPF路由事件应运而生！ WPF的两种树 在正式学习WPF路由事件之前，先了解WPF中的两种树形结构——逻辑树、可视化树，这是理解路由事件的基础。 逻辑树（Logical Tree）：由控件和布局组件组成。 可视化树（Visual Tree）：将控件和布局组件延伸至模板级别，就是可视化树。 以下面这个WPF窗体为例，直观展示WPF这两种属性结构： 12345678910111213141516171819&lt;Window x:Class=&quot;TestWPF01.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:TestWPF01&quot; mc:Ignorable=&quot;d&quot; Title=&quot;MainWindow&quot; SizeToContent=&quot;WidthAndHeight&quot;&gt; &lt;Grid HorizontalAlignment=&quot;Center&quot;&gt; &lt;StackPanel Orientation=&quot;Vertical&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;Button Margin=&quot;5&quot; Content=&quot;按钮1&quot; Width=&quot;150&quot; Height=&quot;30&quot; Click=&quot;Button_Click&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;Button Margin=&quot;5&quot; Content=&quot;按钮2&quot; Width=&quot;150&quot; Height=&quot;30&quot; Click=&quot;Button_Click_1&quot;/&gt; &lt;/StackPanel&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Window&gt; 使用Snoop工具查看窗体的逻辑树： 使用Snoop工具查看窗体的可视化树： 在VS中调试WPF窗体程序时，也可以查看可视化树，与Snoop工具展示的结果一致： 注意：路由事件在可视化树上传递。 路由事件 现在，我们开始探索WPF路由事件是如何避免事件和事件处理器的显式绑定的。 使用步骤 当某个控件产生某种事件时，事件会沿着窗体的可视化树从底向上传播，如果途中节点设置了相应的事件侦听器，那么就会自动做出响应。 因此，使用路由事件非常简单，只需要在控件的某个父类节点上设置事件侦听器。 对于上节的例子： 12345678910111213141516171819&lt;Window x:Class=&quot;TestWPF01.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:TestWPF01&quot; mc:Ignorable=&quot;d&quot; Title=&quot;MainWindow&quot; SizeToContent=&quot;WidthAndHeight&quot;&gt; &lt;Grid HorizontalAlignment=&quot;Center&quot; x:Name=&quot;grid01&quot;&gt; &lt;StackPanel Orientation=&quot;Vertical&quot; x:Name=&quot;sp1&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; x:Name=&quot;sp2&quot;&gt; &lt;Button Margin=&quot;5&quot; Content=&quot;按钮1&quot; Width=&quot;150&quot; Height=&quot;30&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; x:Name=&quot;sp3&quot;&gt; &lt;Button Margin=&quot;5&quot; Content=&quot;按钮2&quot; Width=&quot;150&quot; Height=&quot;30&quot;/&gt; &lt;/StackPanel&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Window&gt; 在窗体的构造函数中设置路由事件侦听器： 123456789101112131415using System.Windows;using System.Windows.Controls;namespace TestWPF01 { public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); this.grid01.AddHandler(Button.ClickEvent, new RoutedEventHandler(this.ButtonClicked)); } private void ButtonClicked(object sender, RoutedEventArgs e) { MessageBox.Show(&quot;有按钮被单击了！&quot;); } }} 也可以在XAML中设置侦听器： 12&lt;Grid HorizontalAlignment=&quot;Center&quot; x:Name=&quot;grid01&quot; Button.Click=&quot;ButtonClicked&quot;&gt;&lt;/Grid&gt; 这时，无论单击哪个按钮，单击事件都会被grid01的侦听器监测到，都会弹出提示框。 获取路由事件的源头 通过路由事件处理器的事件参数可以获得事件源头，其中Source返回逻辑树上的事件源头，OriginalSource返回可视化树上的事件源头。 1234private void ButtonClicked(object sender, RoutedEventArgs e) { MessageBox.Show($&quot;{(e.Source as FrameworkElement).Name} 被单击了！&quot;); MessageBox.Show($&quot;{(e.OriginalSource as FrameworkElement).Name} 被单击了！&quot;);}","link":"/post/3b1c240a4a47/"},{"title":"WPF&#x2F;MVVM系列(6)——MVVM模式","text":"本文以一个小例子介绍了如何采用WPF原生库和CommunityToolkit.Mvvm库实现简单的MVVM模式，后者对MVVM模式的常用功能进行了进一步封装，使用更方便，代码更简洁，在大型项目中可以优先考虑使用。 除了数据和命令绑定，CommunityToolkit.Mvvm库也提供了很多其他功能，比如依赖注入、控制反转等。 对一个设计理念的理解或优秀框架的学习没有止境，后面随着自己理解的深入，我将不断更新本系列文章。 实例说明 本文以一个简单的小实例，说明如何使用WPF的MVVM模式。 窗体上有两个文本框和一个按钮，当两个文本框的内容都不为空时按钮可用，否则不可用。点击按钮后，消息框显示两个文本框里的内容。 原生库 Model 1234public class PersonModel { public string FirstName { get; set; } public string LastName { get; set; }} View 12345678910111213141516&lt;Window x:Class=&quot;TestMvvm.Views.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:TestMvvm.Views&quot; mc:Ignorable=&quot;d&quot; Title=&quot;MainWindow&quot; SizeToContent=&quot;WidthAndHeight&quot;&gt; &lt;Grid&gt; &lt;StackPanel Margin=&quot;10&quot;&gt; &lt;TextBox Text=&quot;{Binding FirstName,UpdateSourceTrigger=PropertyChanged}&quot; Margin=&quot;0 0 0 5&quot; Width=&quot;150&quot; Height=&quot;30&quot;/&gt; &lt;TextBox Text=&quot;{Binding LastName,UpdateSourceTrigger=PropertyChanged}&quot; Margin=&quot;0 0 0 5&quot; Width=&quot;150&quot; Height=&quot;30&quot;/&gt; &lt;Button Content=&quot;提交&quot; Command=&quot;{Binding SubmitCommand}&quot; Width=&quot;150&quot; Height=&quot;30&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Window&gt; （1）按钮的Command也是一个属性，其绑定与文本框Text属性的绑定一样。 （2）设置UpdateSourceTrigger=PropertyChanged，保证文本框内容发生变化时马上更新内存数据。 ViewModel 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100using System;using System.ComponentModel;using System.Runtime.CompilerServices;using System.Windows;using System.Windows.Input;using TestMvvm.Models;namespace TestMvvm.ViewModels { public class PersonViewModel : INotifyPropertyChanged { public PersonViewModel() { _person = new PersonModel(); _submitCommand = new MyCommand(ShowSubmitMessage, EnableSubmit); } #region 界面绑定数据定义 private PersonModel _person; public string FirstName { get { return _person.FirstName; } set { if (_person.FirstName != value) { _person.FirstName = value; OnPropertyChanged(); SubmitCommand.RaiseCanExecuteChange(); } } } public string LastName { get { return _person.LastName; } set { if (_person.LastName != value) { _person.LastName = value; OnPropertyChanged(); SubmitCommand.RaiseCanExecuteChange(); } } } #endregion #region 命令定义 private MyCommand _submitCommand; public MyCommand SubmitCommand { get { return _submitCommand; } set { _submitCommand = value; OnPropertyChanged(); } } #endregion #region 业务处理逻辑，程序的核心 public void ShowSubmitMessage(object parameter) { MessageBox.Show($&quot;FirstName: {FirstName},LastName: {LastName}&quot;); } public bool EnableSubmit(object parameter) { if (FirstName != null &amp;&amp; !string.IsNullOrWhiteSpace(FirstName) &amp;&amp; LastName != null &amp;&amp; !string.IsNullOrWhiteSpace(LastName)) return true; return false; } #endregion public event PropertyChangedEventHandler PropertyChanged; private void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } } /// &lt;summary&gt; /// 自定义命令类 /// &lt;/summary&gt; public class MyCommand : ICommand { private Action&lt;object&gt; execute; private Func&lt;object, bool&gt; canExecute; public MyCommand(Action&lt;object&gt; execute, Func&lt;object, bool&gt; canExecute = null) { this.execute = execute; this.canExecute = canExecute; } public event EventHandler CanExecuteChanged; public bool CanExecute(object parameter) { if (canExecute != null) return canExecute(parameter); return true; } public void Execute(object parameter) { execute?.Invoke(parameter); } public void RaiseCanExecuteChange() { CanExecuteChanged?.Invoke(this, EventArgs.Empty); } }} （1）当属性值发生变化时，调用RaiseCanExecuteChange()函数，触发CanExecute()函数，从而更新按钮的可用状态。 （2）用可读可写属性对命令进行包装，可实现命令的动态改变；但在大多数情况下，一个按钮的逻辑基本是固定的，这里的做法略显过度，可以声明一个只读属性。 12private MyCommand _submitCommand;public MyCommand SubmitCommand =&gt; _submitCommand; （3）这里通过CanExecute()来设置按钮的可用状态，实际上使用多值绑定的方式可以保证UI逻辑更加紧凑。 （4）ViewModel文件中的内容较杂，可以使用#region分块使代码更清晰。 在View.xaml的后台代码中绑定ViewModel 123456789101112using System.Windows;using TestMvvm.ViewModels;namespace TestMvvm.Views { public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); // 绑定ViewModel this.DataContext = new PersonViewModel(); } }} 依旧采用最经典的DataContext方式进行绑定。 CommunityToolkit.Mvvm库 使用当前比较主流的CommunityToolkit.Mvvm库改造以上实例，重点依然集中在数据绑定和命令绑定上。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using CommunityToolkit.Mvvm.ComponentModel;using CommunityToolkit.Mvvm.Input;using System.Windows;using TestMvvm.Models;namespace TestMvvm.ViewModels { public class PersonViewModel : ObservableObject { public PersonViewModel() { _person = new PersonModel(); } #region 界面绑定数据定义 private PersonModel _person; public string FirstName { get =&gt; _person.FirstName; set { SetProperty(_person.FirstName, value, _person, (u, n) =&gt; u.FirstName = n); SubmitCommand.NotifyCanExecuteChanged(); } } public string LastName { get =&gt; _person.LastName; set { SetProperty(_person.LastName, value, _person, (u, n) =&gt; u.LastName = n); SubmitCommand.NotifyCanExecuteChanged(); } } #endregion #region 命令定义 private RelayCommand&lt;object&gt; _submitCommand; public RelayCommand&lt;object&gt; SubmitCommand { get { if (_submitCommand == null) { _submitCommand = new RelayCommand&lt;object&gt;(ShowSubmitMessage, (p) =&gt; { if (FirstName != null &amp;&amp; !string.IsNullOrWhiteSpace(FirstName) &amp;&amp; LastName != null &amp;&amp; !string.IsNullOrWhiteSpace(LastName)) return true; return false; }); } return _submitCommand; } } #endregion #region 业务处理逻辑，程序的核心 public void ShowSubmitMessage(object parameter) { MessageBox.Show($&quot;FirstName: {FirstName},LastName: {LastName}&quot;); } #endregion }} 从以上代码可以看到，相比采用原生的数据和命令绑定，使用CommunityToolkit.Mvvm库后代码量可以进一步下降，且程序的可读性更好，有以下几点需要重点说明下： （1）ViewModel类继承ObservableObject类，在属性的set访问器中调用SetProperty()方法，就可以在更新属性值的同时刷新View上的绑定目标。 （2）SetProperty()方法的最后一个参数是Action类型，用于对value进行数据校验或转换。 （3）RelayCommand是一个泛型命令类，其泛型参数表示命令的参数类型，第一个参数指定命令的Execute()逻辑，第二个参数指定命令的CanExecute()逻辑。 （4）当文本框内容发生变化时，会触发属性的set访问器修改内存数据，这时手动调用命令的NotifyCanExecuteChanged()函数，触发CanExecute()逻辑，从而更新按钮的可用状态。 总结 （1）本文以一个小实例介绍了如何采用WPF原生库和CommunityToolkit.Mvvm库实现简单的MVVM模式，后者对MVVM模式的常用功能进行了封装，使用起来更方便，代码也更简洁，在大型项目中推荐使用。 （2）除了数据绑定和命令绑定外，CommunityToolkit.Mvvm库也提供了其他诸多功能，比如依赖注入、控制反转等，一切都是为了实现“高内聚低耦合”的目标。 （3）对一个设计理念的理解和优秀框架的学习没有止境，随着理解的深入，我会不断更新本系列文章。","link":"/post/2fda69221192/"},{"title":"Windows系统编程——创建新进程","text":"本文概述： 简要介绍Windows程序的启动过程； 详细介绍在控制台程序、窗口程序中获取命令行、环境变量和当前目录的方法； 以Windows API和C#为例，编写创建新进程、设置并获取命令行等数据的完整代码； 介绍环境变量、命令行在VS程序调试、业务开发平台切换中的实际应用。 程序启动过程 关键概念：启动函数、入口函数。 入口函数有4种（main、wmain、WinMain、wWinMain），main、wmain针对控制台程序，WinMain、wWinMain针对窗口程序，具体使用哪种，由程序的子系统类别确定，子系统类别可以在Visual Studio中设置；如果没有设置，以上述第一个出现的函数作为入口函数。w开头的入口函数用于Unicode编码的项目。 链接器根据入口函数种类确定启动函数，启动函数先进行必要的环境设置（包括设置命令行、环境变量等），再调用入口函数。 总结：启动程序时，程序被加载到内存，启动函数执行，先进行环境设置，然后调用入口函数，同时将命令行等参数以实参方式传递给入口函数。入口函数对开发者可见，因此开发者可以获取这些参数。 进程“四大件” 基地址 加载资源时需要使用进程基地址，获取方式如下： 1234567891011121314151617181920212223242526#include &lt;windows.h&gt;#include &lt;tchar.h&gt;extern &quot;C&quot; const IMAGE_DOS_HEADER __ImageBase;void test() { // GetModuleHandle(NULL)获得当前可执行文件的基地址，而非DLL文件的基地址 HMODULE hModule = GetModuleHandle(nullptr); HINSTANCE hInst = (HINSTANCE)&amp;__ImageBase; HMODULE hModule2 = nullptr; // 获取当前函数test所在DLL的基地址 GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, (PCTSTR)test, &amp;hModule2);}int APIENTRY _tWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow){ TCHAR moduleName[256]; GetModuleFileName(GetModuleHandle(nullptr), moduleName, 256); test(); return 0;} 命令行 1、直接获取入口函数参数（控制台程序） 1234567int _tmain(int argc, TCHAR** argv) { _tprintf(_T(&quot;argc=%d\\n&quot;), argc); for (size_t i = 0; i &lt; argc; i++) _tprintf(_T(&quot;argv[%d]=%s\\n&quot;), i, argv[i]); system(&quot;pause&quot;); return 0;} 2、直接获取入口函数参数（窗口程序） 12345678int APIENTRY _tWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, _In_ int nCmdShow){ MessageBox(NULL, lpCmdLine, _T(&quot;温馨提示&quot;), MB_OK); return 0;} 3、通过函数获取（控制台程序、窗口程序） 当前，开发复杂项目时通常使用既有框架（MFC、QT等），有些框架对入口函数进行了封装，开发者无法直接获取入口函数实参，因此只能通过这种方式获取命令行等参数。 123456789101112131415161718192021222324int APIENTRY _tWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, _In_ int nCmdShow){ int nNumArgv; PWSTR* ppArgv = CommandLineToArgvW(GetCommandLineW(), &amp;nNumArgv); for (size_t i = 0; i &lt; nNumArgv; i++) { TCHAR info[256]; swprintf_s(info, _T(&quot;argv[%d]=%s&quot;), i, ppArgv[i]); MessageBox(NULL, info, _T(&quot;温馨提示&quot;), MB_OK); } return 0;}int _tmain(int argc, TCHAR** argv) { int nNumArgv; PWSTR* ppArgv = CommandLineToArgvW(GetCommandLineW(), &amp;nNumArgv); for (size_t i = 0; i &lt; nNumArgv; i++) wprintf(L&quot;argv[%d]=%s\\n&quot;, i, ppArgv[i]); system(&quot;pause&quot;); return 0;} 环境变量 系统会为进程设置初始环境变量，其来源包括3个部分：内置环境变量、用户环境变量和系统环境变量。 子进程可以继承父进程的环境变量。 1、在控制台程序中通过实参获取环境变量 12345678910int _tmain(int argc, TCHAR* argv[], TCHAR* envp[]) { int i = 0; // envp最后一个是nullptr while (envp[i++] != nullptr) { wprintf(L&quot;%s\\n&quot;, envp[i]); } system(&quot;pause&quot;); return 0;} 2、通过GetEnvironmentStrings()获取环境变量块（适用控制台程序、窗口程序，但需要编码解析环境块） 12345int _tmain(int argc, TCHAR* argv[], TCHAR* envp[]) { PTSTR pEnvBlock = GetEnvironmentStrings(); system(&quot;pause&quot;); return 0;} 3、实用函数 GetEnviromentVariable()、ExpandEnviromentStrings()：根据环境变量名查询环境变量值。 SetEnviromentVariable()：设置环境变量值。 当前目录 系统内部会跟踪每个进程的当前驱动器和当前目录，如果不提供文件的完整路径名，进程将在当前驱动器的当前目录查找文件。 如果采用D:ReadMe.txt的方式指定文件路径，默认查找D盘的当前路径，在该路径下找文件；如果没有当前目录，则在D盘根目录下找文件。 12345678910int _tmain(int argc, TCHAR* argv[], TCHAR* envp[]) { DWORD num = GetCurrentDirectory(0, nullptr); PTSTR info = new TCHAR[num]; GetCurrentDirectory(num, info); _tprintf(_T(&quot;%s&quot;), info); delete[] info; system(&quot;pause&quot;); return 0;} 创建新进程的方式 Windows API 在Windows操作系统上，Windows API是创建进程的最底层方式；C#是上层封装。 创建新进程的函数是CreateProcess，其原型如下： 1234567891011121314151617181920212223242526BOOL CreateProcessW( // 应用程序路径，一般不适用该参数，设置为NULL [in, optional] LPCWSTR lpApplicationName, // 进程命令行：空格分隔，第一个为应用程序路径 [in, out, optional] LPWSTR lpCommandLine, // 指定进程权限和线程权限，以及本进程是否继承父进程的句柄 [in, optional] LPSECURITY_ATTRIBUTES lpProcessAttributes, [in, optional] LPSECURITY_ATTRIBUTES lpThreadAttributes, [in] BOOL bInheritHandles, // 指定进程创建标识符 [in] DWORD dwCreationFlags, // 指定本进程的环境变量，为NULL则继承父进程的环境 [in, optional] LPVOID lpEnvironment, // 指定本进程的当前目录 [in, optional] LPCWSTR lpCurrentDirectory, // 进程创建的其他信息 [in] LPSTARTUPINFOW lpStartupInfo, // 返回本进程及其主线程的句柄和ID [out] LPPROCESS_INFORMATION lpProcessInformation); 本文重点关注程序名、命令行和环境变量这三个参数，封装创建进程并设置这三个参数的函数，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;tchar.h&gt;/// @brief 封装创建进程的函数/// @param lpApplicationName 程序名 /// @param numCmds 命令行数量（不包含程序名）/// @param cmds 命令行字符串数组/// @param numEnvs 环境变量数量/// @param envNames 环境变量名字符串数组/// @param envValues 环境变量值字符串数组/// @return 成功返回TRUE，失败返回FALSEBOOL CreateProcessWithCmdAndEnviroment(LPCWSTR lpApplicationName, DWORD numCmds, WCHAR* cmds[], DWORD numEnvs, WCHAR* envNames[], WCHAR* envValues[]) { // 计算总的命令行字符串长度 int num = 0; num += (wcslen(lpApplicationName) + 3); for (size_t i = 0; i &lt; numCmds; i++) num += (wcslen(cmds[i]) + 1); num++; // 组装命令行字符串 WCHAR* cmd = new WCHAR[num]; wcscpy_s(cmd, num, L&quot;\\&quot;&quot;); // 用引号包裹程序路径，应对路径中包含空格的情况 wcscat_s(cmd, num, lpApplicationName); wcscat_s(cmd, num, L&quot;\\&quot;&quot;); for (size_t i = 0; i &lt; numCmds; i++) { wcscat_s(cmd, num, L&quot; &quot;); wcscat_s(cmd, num, cmds[i]); } for (size_t i = 0; i &lt; numEnvs; i++) SetEnvironmentVariable(envNames[i], envValues[i]); STARTUPINFO startupInfo = { sizeof(startupInfo) }; PROCESS_INFORMATION processInfo; BOOL flag = CreateProcess(nullptr, cmd, nullptr, nullptr, FALSE, 0, nullptr, nullptr, &amp;startupInfo, &amp;processInfo); delete[] cmd; return flag;}int _tmain() { // 设置命令行参数 WCHAR cmd1[] = L&quot;hello&quot;; WCHAR cmd2[] = L&quot;world&quot;; WCHAR* cmds[] = { cmd1,cmd2 }; // 设置环境变量参数 WCHAR envName1[] = L&quot;env1&quot;; WCHAR envName2[] = L&quot;env2&quot;; WCHAR envValue1[] = L&quot;envValue1&quot;; WCHAR envValue2[] = L&quot;envValue2&quot;; WCHAR* envNames[] = { envName1,envName2 }; WCHAR* envValues[] = { envValue1,envValue2 }; CreateProcessWithCmdAndEnviroment(L&quot;E:\\\\Desktop\\\\WindowsViaC\\\\Debug\\\\LHTest.exe&quot;, 2, cmds, 2, envNames, envValues); return 0;} 为验证该函数的正确性，编写一个测试程序，用于打印命令行参数和环境变量，如下所示： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;#include &lt;tchar.h&gt;/// @brief 打印指定名称的环境变量/// @param name 环境变量名void PrintEnviromentVariable(PCTSTR name) { PTSTR value = NULL; DWORD res = GetEnvironmentVariable(name, value, 0); if (res != 0) { DWORD size = res * sizeof(TCHAR); value = (PTSTR)malloc(size); GetEnvironmentVariable(name, value, size); _tprintf(_T(&quot;%s=%s\\n&quot;), name, value); free(value); } else _tprintf(_T(&quot;'%s'=&lt;unknown value&gt;\\n&quot;), name);}int _tmain() { // 打印环境变量名 wprintf(L&quot;环境变量：\\n&quot;); PrintEnviromentVariable(_T(&quot;env1&quot;)); PrintEnviromentVariable(_T(&quot;env2&quot;)); // 打印命令行 wprintf(L&quot;\\n命令行：\\n&quot;); int nNumArgv; PWSTR* ppArgv = CommandLineToArgvW(GetCommandLineW(), &amp;nNumArgv); for (size_t i = 0; i &lt; nNumArgv; i++) wprintf(L&quot;argv[%d]=%s\\n&quot;, i, ppArgv[i]); system(&quot;pause&quot;); return 0;} C# 由于Windows API使用起来较为复杂，业务开发时通常使用更高级的编程语言或程序库，例如C#。 使用C#创建新进程的核心是ProcessStartInfo类，其主要属性如下图所示： 创建新进程的程序示例如下： 1234567891011121314151617181920212223using NPOI.HSSF.UserModel;using NPOI.SS.UserModel;using NPOI.XSSF.UserModel;using System;using System.Data;using System.Diagnostics;using System.IO;namespace Test { class Program { static void Main(string[] args) { ProcessStartInfo process = new ProcessStartInfo(); process.UseShellExecute = false; process.FileName = @&quot;LHTest.exe&quot;; process.Arguments = string.Format(&quot;{0} {1}&quot;, &quot;C#&quot;, &quot;Windows&quot;); process.Environment.Add(&quot;env1&quot;, &quot;This is env1&quot;); process.Environment.Add(&quot;env2&quot;, &quot;This is env2&quot;); Process.Start(process); Console.ReadLine(); } }} 业务开发场景 VS程序调试小技巧 以QT为例，在Visual Stusio中开发QT桌面软件时，如果没有指定QT依赖库路径，调试时会报错。 大多数开发者的做法是：将QT依赖库的路径直接添加到PATH系统变量（或PATH用户变量）中。 以上做法可行，但存在若干不足：（1）系统对PATH环境变量的长度有限制，随意增加PATH变量长度存在风险；（2）无法应对多版本QT的开发调试。 最佳做法：在Visual Stusio中针对单个项目设置环境变量，如下图所示： 平台切换最佳方案 在某些业务场景下，需要在程序1中启动程序2，并且希望在程序2启动后判断自己是否由程序1启动（众所周知，程序2也可以由用户双击启动），然后根据启动方式做不同的操作。 为此，我们可以借助命令行参数进行判断： 程序1启动程序2之前，先生成一个不会重复的标识字符串（例如GUID），将该字符串写到本地文件（约定文件位置）； 程序1启动程序2时，将该字符串以命令行参数的方式传递给新进程； 新进程启动后，获取命令行参数，并读取本地文件里的标识字符串，将两者进行对比，相同则说明该进程是由程序1启动的，不同则不是。","link":"/post/542884848011/"},{"title":"log4net日志库的基本使用","text":"日志在大型软件开发过程中扮演着不可或缺的角色，开发者经常使用它对系统进行调试和监控。 log4net是.NET平台上非常流行的日志库，网上零碎教程鱼龙混杂，花费良久才搭建起可用的基本框架。 本文简单介绍它的使用步骤，后续会专门写篇文章深入剖析其配置文件。 配置文件 配置文件是日志库的核心，在此可以按照日志需求定义复杂的功能。后续将深化这一部分。 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;configuration&gt; &lt;configSections&gt; &lt;section name=&quot;log4net&quot; type=&quot;log4net.Config.Log4NetConfigurationSectionHandler,log4net&quot; /&gt; &lt;/configSections&gt; &lt;log4net&gt; &lt;logger name=&quot;loginfo&quot;&gt; &lt;level value=&quot;INFO&quot; /&gt; &lt;appender-ref ref=&quot;InfoAppender&quot; /&gt; &lt;/logger&gt; &lt;appender name=&quot;InfoAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&gt; &lt;file value=&quot;C:\\test.log&quot; /&gt; &lt;appendToFile value=&quot;true&quot; /&gt; &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;maximumFileSize value=&quot;100KB&quot; /&gt; &lt;maxSizeRollBackups value=&quot;2&quot; /&gt; &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt; &lt;conversionPattern value=&quot;%message%newline&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;/log4net&gt;&lt;/configuration&gt; 工具类 在工具类中加载日志配置文件，定义写日志方法。 12345678910111213141516171819using log4net;using log4net.Config;using System.IO;using System.Reflection;namespace TestLog4net { public static class Log { private static readonly ILog log = LogManager.GetLogger(&quot;loginfo&quot;); static Log() { var cpath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location); XmlConfigurator.ConfigureAndWatch(new FileInfo(Path.Combine(cpath, &quot;log4net.config&quot;))); } public static void Info(string message) { log.Info(message); } }} 写日志 123456789101112131415using System;namespace TestLog4net { internal class Program { static void Main(string[] args) { Log.Info(&quot;开始记录日志：&quot;); for (int i = 0; i &lt; 100; i++) { Log.Info($&quot;{i}&quot;); } Console.WriteLine(&quot;日志记录完毕。&quot;); Console.Read(); } }}","link":"/post/2c88a9207f69/"},{"title":"wxWidgets开发环境搭建","text":"对wxWidgets早有耳闻，一直没有尝试，近期出于好奇心折腾一番，顿觉相遇恨晚！写篇文章介绍下wxWidgets开发环境的搭建过程。 介绍 在Windows上，GUI开发技术众多，可谓令人眼花缭乱，如：原始底层的Windows API、颇具争议的元老MFC、以强悍闻于世的QT、曾经的快速开发霸主Delphi/C+ + Builder、Delphi开源继承者Lazarus、小众的DirectUI代表Duilib… 我一直在尝试不同的开发技术，希望找到一种基于C+ +的兼顾发行体积、开发效率和易用性的开发方案。“道生一，一生二，二生三，三生万物”，Windows API可谓其中的“一”，但其开发效率过低，许多细节问题需要自己处理；MFC与Windows操作系统深度融合，工业软件用之甚多，如土木工程软件领域的盈建科、理正工具箱等，但该框架封装较浅、界面布局方案匮乏、功能停更等问题一直为人诟病；QT以跨平台和功能强悍著称，其软件打包体积也过于庞大，开发中小程序时总有一种”杀鸡用牛刀“的错觉；如果C+ + Builder的Bug能少一些，像Visual Studio社区版那样降低其注册门槛，也许会受到我这类钟情于桌面程序的开发者的追捧；Lazarus号称Delphi的开源继承者，可惜在语言的扩展性和生态上，Pascal难望C+ +项背；Duilib适合做小而美的程序，控件种类少是它的不足之处，但借助它了解DirectUI这种开发思想也未尝不可。 对wxWidgets早有耳闻，一直没有尝试，近期出于好奇心折腾一番，顿觉相遇恨晚！在我看来其优势如下： 属于跨平台开发框架，但在不同平台上依赖平台特定接口实现，开发的程序具备原生性，可兼顾发行体积和运行性能； 内置了100多种控件，相比于MFC，其布局控件最引人注目，基本到达了Delphi/C+ + Builder、QT、WPF同层次； 采用C+ +开发，同时提供其它语言的调用接口（如Python），框架适用性和扩展性较强； 以较宽松的开源协议发行，可放心采用静态链接方式； 可方便查看源代码，深入掌握该框架的底层机制； 编译速度较快，如果手动编译过QT源码，将深刻体会这一点！ 总而言之，符合我对GUI开发框架的要求。话不多说，写篇文章介绍下wxWidgets开发环境的搭建过程。 步骤 1、源码安装：官网（https://wxwidgets.org/）下载源码，在Windows上优先下载安装版本。 2、安装完成后，如D:\\wxWidgets-3.2.4，打开D:\\wxWidgets-3.2.4\\build\\msw路径，打开相应版本的解决方案。 3、编译需要的版本，其中Debug、Release是静态库版本。 4、编译完成之后，新建空的Desktop Application程序。 5、打开“属性管理器”，引入wxWidgets根目录下的属性文件wxWidgets.props，即可配置好头文件、dll和lib的路径，编写程序即可。 界面设计 墙裂推荐wxFormBuilder，继续探索吧！","link":"/post/828eef541164/"},{"title":"wxWidgets项目的最佳开发流程","text":"这种自动编译xrc文件、派生窗体类的机制将变化控制在wxFormBuilder界面设计上，一定程度上缓解了工具自动生成代码和手动调整代码两者之间的矛盾，从而保证了开发流程的连贯性。 近期，对wxWidgets框架进行了断断续续的摸索，基本确定将它作为今后开发个人桌面小工具的首选技术，并打算对其设计逻辑和源代码进行适当探索。 上一篇关于wxWidgets的文章介绍了如何安装编译源代码、引入props配置文件，从而创建一个可运行的wxWidgets项目。但在实际项目开发过程中，开发环境配置只是第一步，要保证开发效率，还需要一整套流程来应对前端界面和后端业务交互迭代的情况。 推荐使用wxFormBuilder进行wxWidgets项目的前端界面设计，具体的使用方式有多种：①直接使用该工具生成的C+ +代码；②直接使用该工具生成的XRC资源文件；③使用XRC资源文件编译得到的C+ +代码。 以上第②种方式生成的程序在运行时必须附带XRC资源文件，而采用第①、③种方式时，资源文件可以嵌入程序，发行更方便。另外，使用wxFormBuilder生成代码时，最好不要手动调整这些生成代码，防止前端界面更新迭代时覆盖手动调整的内容。 推荐采用方式③进行前端界面开发，在此基础上探索wxWidgets项目的最佳开发流程。本文示例代码也可以作为wxWidgets项目的开发模板。 基本项目配置 新建VC+ +空项目 设置“配置属性——链接器——系统——子系统”为“窗口 (/SUBSYSTEM:WINDOWS)” 导入wxWidgets-3.2.4\\wxwidgets.props项目配置文件，无需手动设置头文件路径和依赖库 新建main.cpp文件，定义wxApp的派生类（程序启动类） 12345678910111213#include &quot;wx/wx.h&quot;class MyApp :public wxApp {public: virtual bool OnInit();};wxIMPLEMENT_APP(MyApp);bool MyApp::OnInit() { if (!wxApp::OnInit()) return false; return true;} wxFormBuilder设计GUI 新建wxFormBuilder项目，设置文件名，设置生成XRC文件 设计窗体 生成XRC代码 将XRC编译成C+ +代码 wxWidgets源码安装路径下有XRC编译器源码（wxWidgets-3.2.4\\utils\\wxrc\\），需要手动编译，编译完成之后得到wxrc.exe可执行文件。 wxrc.exe基本用法 wxrc.exe -c：将XRC编译成C+ +源文件，用来替代XRC文件 wxrc.exe -c -e：除了生成上述C+ +源文件外，还可以生成额外的头文件，头文件中已经获得了各控件的指针变量。 编译XRC：wxrc.exe -c -e resource.xrc 项目生成时自动编译XRC：设置xrc文件的配置属性，添加自定义生成工具，这样项目重新生成时可根据文件是否更新来选择是否重新编译xrc文件。 命令行：D:\\wxWidgets-3.2.4\\utils\\wxrc\\vc_x64_mswu\\wxrc.exe -c -e %(FullPath) .%(Filename).xrc 输出：%(Filename).h;%(Filename).cpp 引入C+ +代码并扩展窗体类 从xrc文件编译而来的头文件和源文件中不包含事件绑定、事件处理等代码，如果开发者直接在生成代码中添加这些逻辑，这些手动修改的内容会在下次重新编译XRC文件后被覆盖，因此禁止手动修改生成代码，可在新的代码文件中继承生成代码中的窗体类来添加这些额外逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#pragma once#include &quot;wx/wx.h&quot;#include &quot;wx/xrc/xmlres.h&quot;#include &quot;resource.h&quot;class MyDialog2Derived :public MyDialog2{public: MyDialog2Derived() :MyDialog2(nullptr) { // 绑定按钮事件 m_btnAdd-&gt;Bind(wxEVT_BUTTON, &amp;MyDialog2Derived::OnAdd, this); m_btnSubtract-&gt;Bind(wxEVT_BUTTON, &amp;MyDialog2Derived::OnSubtract, this); m_btnExit-&gt;Bind(wxEVT_BUTTON, &amp;MyDialog2Derived::OnExit, this); m_button7-&gt;Bind(wxEVT_BUTTON, &amp;MyDialog2Derived::OnExit, this); } /// @brief 加运算 /// @param event void OnAdd(wxCommandEvent&amp; event) { double num1, num2; if (!m_textNum1-&gt;GetValue().ToDouble(&amp;num1) || !m_textNum2-&gt;GetValue().ToDouble(&amp;num2)) { m_textRes-&gt;SetValue(&quot;&quot;); wxMessageBox(&quot;操作数非法，请重新输入！&quot;, &quot;温馨提示&quot;, wxOK | wxICON_ERROR); return; } double res = num1 + num2; m_textRes-&gt;SetValue(wxString::Format(&quot;%.3f&quot;,res)); } /// @brief 减运算 /// @param event void OnSubtract(wxCommandEvent&amp; event) { double num1, num2; if (!m_textNum1-&gt;GetValue().ToDouble(&amp;num1) || !m_textNum2-&gt;GetValue().ToDouble(&amp;num2)) { m_textRes-&gt;SetValue(&quot;&quot;); wxMessageBox(&quot;操作数非法，请重新输入！&quot;, &quot;温馨提示&quot;, wxOK | wxICON_ERROR); return; } double res = num1 - num2; m_textRes-&gt;SetValue(wxString::Format(&quot;%.3f&quot;, res)); } /// @brief 退出事件 /// @param event void OnExit(wxCommandEvent&amp; event) { Close(true); }}; 同时，要更新MyApp类的内容：加载资源、创建顶层窗体 123456789101112131415161718192021222324252627282930#include &quot;wx/wx.h&quot;#include &quot;wx/xrc/xmlres.h&quot;#include &quot;resource.h&quot;#include &quot;MyDialog2Derived.h&quot;class MyApp :public wxApp {public: virtual bool OnInit();private: MyDialog2Derived* dlg;public:};wxIMPLEMENT_APP(MyApp);bool MyApp::OnInit() { if (!wxApp::OnInit()) return false; wxXmlResource::Get()-&gt;InitAllHandlers(); InitXmlResource(); dlg = new MyDialog2Derived(); dlg-&gt;ShowModal(); dlg-&gt;Destroy(); return true;} 将变化点限制在GUI设计 流程总结：使用wxFormBuilder设计界面生成xrc文件；将xrc编译成C+ +头文件和源文件；引用生成的C+ +代码，派生其窗体类，在子类中实现窗体的事件处理逻辑；在App类的OnInit()函数中创建子类实例，运行之。 在业务开发过程中，当前端界面GUI发生变化时，只需要在wxFormBuilder中重新生成xrc文件，然后重新编译项目即可。这种xrc自动编译、派生类机制将变化点限值在GUI设计，避免了工具自动生成代码和手动调整代码之间的矛盾性，从而保证了开发工作的连贯性。","link":"/post/815638a8236e/"},{"title":"一切软件开发都是二次开发","text":"说到二次开发，接触比较多的是AutoCAD二次开发、Revit二次开发，这些都属于典型的二次开发。二次开发的直观定义是：基于某一个软件提供的接口进行编程开发，从而实现对这个软件的操作自动化。但今天我要更进一步提出“一切软件开发都是二次开发”这个观点。 软件分为系统软件和应用软件两类，除操作系统外的系统软件和所有的应用软件都运行在操作系统上，而凡是运行在操作系统上的软件，必定依赖操作系统的接口，自然可以归类到二次开发的范畴。 比较特殊的是操作系统，操作系统是对硬件的第一层抽象和虚拟，是实现上层应用软件和硬件交互的桥梁。其中最重要的硬件莫过于CPU，那么操作系统是如何虚拟CPU的呢？CPU依靠指令驱动，向CPU输入什么指令，CPU的状态就会发生对应变化，这种指令和状态的对应关系就是CPU设计者制定的协议，也就是大名鼎鼎的指令集。操作系统要想抽象虚拟CPU，势必借助CPU指令集，由此来看，操作系统借助CPU指令集来进行二次开发。 综上，一切软件开发都是二次开发。 这种高层依赖低层滚雪球式的计算机技术发展，其实就是人类知识与文明不断积累演化方式的显著体现，优秀的文明总是更大概率地被效仿和传承。回到知识学习这个角度，我们学习任何新事物（高层），其实都不是从零开始，而是依赖某些已有的知识和公理（低层接口）进行猜测和推理。如果就着依赖关系不断去挖掘低层知识，恐怕无穷无尽，就会发出“生有涯，知无涯”的感叹了！","link":"/post/559d2dccd47d/"},{"title":"三类块操作","text":"块在AutoCAD中扮演着重要角色，它可以把多个图形组成一个整体，起到组织图形层次和图元复用的作用。 AutoCAD中有三种类型的块：普通快、动态属性块（可根据属性值修改图形尺寸）、增强属性块（在块中添加文字动态属性），后面两种在第一种的基础上添加了个性化功能。 本文针对这三类块封装若干二次开发接口。 普通块 AddBlockTableRecord：添加块定义（块参照的模板） InsertBlockReference：添加块参照 RemoveBlockRefrences：根据块定义名删除块参照 GetBlockReferenceByName：根据块定义名获取所有块参照 GetEntitiesInBlockReference：获取块参照中的所有实体（考虑块的深度遍历） GetPointInTotalSystem：获取块参照中某点（块参照的局部坐标系）的全局坐标 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public static ObjectId AddBlockTableRecord(Document doc, string blockName, List&lt;ObjectId&gt; ents){ Database db = doc.Database; ObjectId resId = ObjectId.Null; using (Transaction transaction = db.TransactionManager.StartTransaction()) { BlockTable bt = db.BlockTableId.GetObject(OpenMode.ForWrite) as BlockTable; if (bt.Has(blockName)) doc.RemoveBlockDefinition(blockName); BlockTableRecord btr = new BlockTableRecord(); btr.Name = blockName; resId = bt.Add(btr); transaction.AddNewlyCreatedDBObject(btr, true); ObjectIdCollection collection = new ObjectIdCollection(ents.ToArray()); IdMapping mapping = new IdMapping(); db.DeepCloneObjects(collection, resId, mapping, false); transaction.Commit(); } return resId;}public static ObjectId InsertBlockReference(Database db, string blockName, Point3d position, Scale3d scale, double rotateAngle){ ObjectId blockReferenceId; using (Transaction transaction = db.TransactionManager.StartTransaction()) { BlockTable blockTable = db.BlockTableId.GetObject(OpenMode.ForWrite) as BlockTable; if (!blockTable.Has(blockName)) return ObjectId.Null; BlockTableRecord blockTableRecord = transaction.GetObject(blockTable[BlockTableRecord.ModelSpace], OpenMode.ForWrite) as BlockTableRecord; BlockReference blockReference = new BlockReference(position, blockTable[blockName]); blockReference.ScaleFactors = scale; blockReference.Rotation = rotateAngle; blockReferenceId = blockTableRecord.AppendEntity(blockReference); transaction.AddNewlyCreatedDBObject(blockReference, true); blockTable.DowngradeOpen(); transaction.Commit(); } return blockReferenceId;}public static void RemoveBlockRefrences(this Document doc, string name){ List&lt;BlockReference&gt; blocks = GetBlockReferenceByName(doc, name); ObjectId[] objectIds = new ObjectId[blocks.Count]; for (int i = 0; i &lt; blocks.Count; i++) { BlockReference block = blocks[i]; objectIds[i] = block.ObjectId; } DwgPainter.DeleteEntities(doc.Database, objectIds);}public static List&lt;BlockReference&gt; GetBlockReferenceByName(this Document doc, string name){ List&lt;BlockReference&gt; blockReferences = new List&lt;BlockReference&gt;(); Database db = doc.Database; using (Transaction transaction = doc.TransactionManager.StartTransaction()) { BlockTable bt = transaction.GetObject(db.BlockTableId, OpenMode.ForRead) as BlockTable; BlockTableRecord btr = transaction.GetObject(bt[BlockTableRecord.ModelSpace], OpenMode.ForRead) as BlockTableRecord; foreach (ObjectId id in btr) { Entity entity = transaction.GetObject(id, OpenMode.ForRead) as Entity; if (entity is BlockReference &amp;&amp; (entity as BlockReference).Name == name) { blockReferences.Add(entity as BlockReference); } } transaction.Commit(); } return blockReferences;}public static List&lt;Entity&gt; GetEntitiesInBlockReference(BlockReference block){ if (block == null) return null; List&lt;Entity&gt; entities = new List&lt;Entity&gt;(); Queue&lt;BlockReference&gt; blocks = new Queue&lt;BlockReference&gt;(); blocks.Enqueue(block); while (blocks.Count &gt; 0) { BlockReference blockReference = blocks.Dequeue(); DBObjectCollection objects = new DBObjectCollection(); blockReference.Explode(objects); foreach (var obj in objects) { if (obj is BlockReference) blocks.Enqueue(obj as BlockReference); else if (obj is Line || obj is Polyline || obj is Circle || obj is Arc || obj is Polyline2d) entities.Add(obj as Entity); } } return entities;}public static bool GetPointInTotalSystem(BlockReference reference, Point3d pointInLocalSystem, out Point3d pointInTotalSystem){ pointInTotalSystem = Point3d.Origin; if (reference == null) return false; Point3d insertPoint = reference.Position; double factor = reference.ScaleFactors.X; double angle = reference.Rotation; double dist = Math.Sqrt(pointInLocalSystem.X * pointInLocalSystem.X + pointInLocalSystem.Y * pointInLocalSystem.Y) * factor; double angleDefiniton = DwgPainter.Arctan(pointInLocalSystem.Y, pointInLocalSystem.X); angle += angleDefiniton; if (angle &gt; Math.PI * 2) { angle -= Math.PI * 2; } pointInTotalSystem = new Point3d(insertPoint.X + dist * Math.Cos(angle), insertPoint.Y + dist * Math.Sin(angle), 0); return true;} 动态属性块 普通快的所有方法也适用于动态属性块 GetDynamicBlockPropertyValue：获取某一实体的某一属性值 SetDynamicBlockDistance：设置某一实体某一属性的值（值类型为距离） SetDynamicBlockPropertyValue：设置某一实体某一属性的值（值类型为距离） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public static Object GetDynamicBlockPropertyValue(this ObjectId id, string propertyName){ Database db = id.Database; object value = null; using (Transaction transaction = db.TransactionManager.StartTransaction()) { Entity entity = transaction.GetObject(id, OpenMode.ForRead) as Entity; if (entity is BlockReference &amp;&amp; (entity as BlockReference).IsDynamicBlock) { var props = (entity as BlockReference).DynamicBlockReferencePropertyCollection; foreach (DynamicBlockReferenceProperty prop in props) if (prop.PropertyName == propertyName) value = prop.Value; } transaction.Commit(); } return value;}public static void SetDynamicBlockDistance(this ObjectId id,string propertyName, double distance){ Database db = id.Database; using (Transaction transaction = db.TransactionManager.StartTransaction()) { Entity entity = transaction.GetObject(id, OpenMode.ForWrite) as Entity; if (entity is BlockReference &amp;&amp; (entity as BlockReference).IsDynamicBlock) { var props = (entity as BlockReference).DynamicBlockReferencePropertyCollection; foreach (DynamicBlockReferenceProperty prop in props) { if (!prop.ReadOnly &amp;&amp; prop.PropertyName == propertyName &amp;&amp; prop.UnitsType == DynamicBlockReferencePropertyUnitsType.Distance) { object val = distance; prop.Value = val; } } } transaction.Commit(); }}public static void SetDynamicBlockPropertyValue(this ObjectId id, string propertyName, string value){ Database db = id.Database; using (Transaction transaction = db.TransactionManager.StartTransaction()) { Entity entity = transaction.GetObject(id, OpenMode.ForWrite) as Entity; if (entity is BlockReference &amp;&amp; (entity as BlockReference).IsDynamicBlock) { var props = (entity as BlockReference).DynamicBlockReferencePropertyCollection; foreach (DynamicBlockReferenceProperty prop in props) { if (!prop.ReadOnly &amp;&amp; prop.PropertyName == propertyName &amp;&amp; prop.UnitsType == DynamicBlockReferencePropertyUnitsType.NoUnits) { object val = value; prop.Value = val; } } } transaction.Commit(); }} 增强属性块 普通快的所有方法也适用于增强属性块 InsertBlockWithAttribute：插入增强属性块的同时并设置其中的文字（必须设置，不然增强属性文字会消失，后续无法修改） ChangeBlockAttributes：修改增强属性块中的文字 ChangeBlockAttributesColor：修改块中增强文字的颜色 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public static ObjectId InsertBlockWithAttribute(this Document doc, string blockName, Point3d insertPoint,string layerName, Dictionary&lt;string, string&gt; attributes, double rotateAngle = 0.0, double scaleFactor = 1.0, string layoutName = &quot;&quot;){ Database db = doc.Database; ObjectId backObjectId = ObjectId.Null; using (var docLock = doc.LockDocument()) { using (Transaction transaction = db.TransactionManager.StartTransaction()) { BlockTable bt = transaction.GetObject(db.BlockTableId, OpenMode.ForRead) as BlockTable; BlockTableRecord modelSpace = null; ObjectId objectId = ObjectId.Null; if (!string.IsNullOrWhiteSpace(layoutName)) { var layoutId = db.GetLayoutIdByName(layoutName); if (layoutId != ObjectId.Null) objectId = layoutId; else return backObjectId; } else objectId = bt[BlockTableRecord.ModelSpace]; modelSpace = transaction.GetObject(objectId, OpenMode.ForWrite) as BlockTableRecord; if (bt.Has(blockName)) { BlockTableRecord btr = transaction.GetObject(bt[blockName], OpenMode.ForRead) as BlockTableRecord; BlockReference blockReference = new BlockReference(insertPoint, bt[blockName]); LayerTable layerTable = transaction.GetObject(db.LayerTableId, OpenMode.ForRead) as LayerTable; if (layerTable.Has(layerName)) blockReference.Layer = layerName; else blockReference.Layer = &quot;0&quot;; blockReference.Rotation = rotateAngle; blockReference.ScaleFactors = new Scale3d(scaleFactor); backObjectId = modelSpace.AppendEntity(blockReference); if (btr.HasAttributeDefinitions) { foreach (ObjectId id in btr) { DBObject obj = id.GetObject(OpenMode.ForWrite); if (obj is AttributeDefinition) { AttributeReference attrRef = new AttributeReference(); attrRef.SetAttributeFromBlock((AttributeDefinition)obj, blockReference.BlockTransform); if (attributes.ContainsKey(attrRef.Tag.ToString())) { var value = attributes[attrRef.Tag.ToString()]; if (value == null) value = &quot;&quot;; attrRef.TextString = value; blockReference.AttributeCollection.AppendAttribute(attrRef); transaction.AddNewlyCreatedDBObject(attrRef, true); } } } } transaction.AddNewlyCreatedDBObject(blockReference, true); } transaction.Commit(); return backObjectId; } }}public static void ChangeBlockAttributes(this Document doc, BlockReference blockReference, Dictionary&lt;string, string&gt; attributes){ if (blockReference == null || attributes == null || attributes.Count == 0) return; var attrs = blockReference.AttributeCollection; if (attrs.Count == 0) return; using (Transaction transaction = doc.TransactionManager.StartTransaction()) { foreach (var attr in attrs) { AttributeReference attrRef = null; if (attr is ObjectId) attrRef = transaction.GetObject((ObjectId)attr, OpenMode.ForWrite) as AttributeReference; else if (attr is AttributeReference) attrRef = attr as AttributeReference; if (attrRef != null &amp;&amp; attributes.ContainsKey(attrRef.Tag.ToString())) attrRef.TextString = attributes[attrRef.Tag.ToString()]; } transaction.Commit(); }}public static void ChangeBlockAttributesColor(this Document doc, BlockReference blockReference, int colorIndex){ if (doc == null || blockReference == null) return; var attrs = blockReference.AttributeCollection; if (attrs.Count == 0) return; using (Transaction transaction = doc.TransactionManager.StartTransaction()) { foreach (var attr in attrs) { AttributeReference attrRef = null; if (attr is ObjectId) attrRef = transaction.GetObject((ObjectId)attr, OpenMode.ForWrite) as AttributeReference; else if (attr is AttributeReference) attrRef = attr as AttributeReference; if (attrRef != null) attrRef.ColorIndex = colorIndex; } transaction.Commit(); }}","link":"/post/75d48c9978ad/"},{"title":"与《码农翻身》作者共鸣","text":"前不久，无意间看到了一本书——《码农翻身》，作者刘欣，前IBM系统架构师，可谓IT工业界的翘楚。作者语言诙谐，对软件开发领域的关键知识如数家珍、娓娓道来，字里行间流露出对软件开发的满腔热忱。其中，作者谈论“好奇心”的文字打动了我。 作为一名土木工程从业者，我在上大学时就对软件开发产生了浓厚兴趣，捣腾了很久，更多是走弯路，以致于现在也没能攒够足以和科班大牛一较高下的开发经验和硬核技能。我对软件开发领域的摸索长期游离在表面，缺乏系统学习，从某种程度来说这份热爱是肤浅的，就像恋爱中的小情侣，嘴巴说着甜言蜜语，实际却一毛不拔。但无论如何，这份肤浅的热爱至今没有消退，更需要做的是看清本质、合理规划、稳扎稳打！ 高考填志愿时眼界狭窄，缺乏选择能力，稀里糊涂进入土木工程专业，入学后才发现自己的分数比专业线高出二十多分，别人问我为什么这么认定土木，我笑呵呵说这是天意。即使到现在我也谈不上后悔，人的想法和一时兴趣都是善变的，时代变迁、环境影响暂不必说，就算是旁人的一句吐槽也可能牵动敏感的神经。相反，我觉得一切是最好的安排，正是这样的经历让我更加深刻地感受到热爱的力量。本科四年，我与大多数同学一样，按部就班地上课写作业学习，大三冲击心目中的“土木圣地”——同济大学，保研成功后兴奋了好几天。可现在看来，令我印象深刻的大学片段寥寥无几，不得不承认我的大学生活终究过得平平无奇，呵呵！成功人士往往个性鲜明，听从内心，不拘常规，脚步紧跟嗅觉。雷军只用两年时间完成大学课程，进行了大量训练，掌握了常人无法匹敌的技能，甚至开始体会创业的苦与乐，他的四年胜过很多人十年、二十年甚至一辈子。这么来看，找到热爱，充分利用时间，朝着正确方向前进，是多么让人羡慕的一件事！ 在斯坦福大学2005届毕业典礼上，乔布斯发表了至今仍被奉为经典的演讲，其中也有对热爱的诠释： Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma – which is living with the results of other people’s thinking. Don’t let the noise of other’s opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary. 平凡但热爱不能缺席，精耕细作、积攒力量，漫漫职业旅途也有一份平实的期待！ 新的一年，更从容、更明智、更向上！","link":"/post/d73e7037b197/"},{"title":"创建型设计模式","text":"本文简要介绍五种类创建型设计模式。 工厂方法（Factory Method） 工厂方法模式，其侧重于在一个方法中创建商品，该方法类似一个工厂。有两种常见的使用方法。 定义一个创建方法，通过参数来确定要创建的具体商品类型 定义工厂子类，每个子类负责创建一种具体商品 抽象工厂（Abstract Factory） 抽象工厂模式，每一个具体工厂都负责一系列商品的创建，且每个具体工厂创建的商品系列是一样的，比较容易理解。 建造者（Builder） 建造者模式，侧重于一步步构建一个复杂对象；与之类似的抽象工厂模式则关注构建一系列对象。 原型（Prototype） 原型模式，强调通过克隆已有的类实例来创建对象。 单例（Singleton） 单例模式，强调一个类只有唯一的实例。该设计模式的重点在于如何实现，不考虑线程安全时，分为懒汉式和饿汉式两种实现方法。 ”懒汉式” 1234567891011121314151617181920class Singleton {private: static Singleton* instance;private: Singleton() {}public: static Singleton* GetInstance() { if (instance == nullptr) instance = new Singleton(); return instance; }};Singleton* Singleton::instance = nullptr;int main() { auto s = Singleton::GetInstance(); return 0;} “饿汉式” 123456789101112131415161718class Singleton {private: static Singleton* instance;private: Singleton() {}public: static Singleton* GetInstance() { return instance; }};Singleton* Singleton::instance = new Singleton();int main() { auto s = Singleton::GetInstance(); return 0;}","link":"/post/141def1363f4/"},{"title":"吃哪些苦？","text":"吃苦是手段，为的是达成目标，不是为了感动自己或他人，不是为了吃苦而吃苦，更不是为了攀比，警惕成为职场中勤奋的“懒惰者”！","link":"/post/582b7e689e06/"},{"title":"判断点在有向线段的左（右）侧","text":"要判断平面内一个点位于有向线段的左侧还是右侧，可以结合向量叉乘、向量点乘的代数和几何意义来进行计算判断。 数学基础 a⃗=(x1,y1,0)b⃗=(x2,y2,0)\\vec{a}=(x_1,y_1,0)\\\\ \\vec{b}=(x_2,y_2,0) a=(x1​,y1​,0)b=(x2​,y2​,0) 向量点乘 两个向量点乘的结果是一个标量，有以下两种算法。 代数 a⃗⋅b⃗=x1⋅x2+y1⋅y2\\vec{a}\\cdot\\vec{b}=x_1 \\cdot x_2+y_1 \\cdot y_2 a⋅b=x1​⋅x2​+y1​⋅y2​ 几何 a⃗⋅b⃗=∣a∣⋅∣b∣⋅cosθθ:向量a⃗和b⃗之间的夹角，θ∈[0,π]\\vec{a}\\cdot\\vec{b}=\\lvert{a}\\rvert \\cdot \\lvert{b}\\rvert \\cdot cos\\theta\\\\ \\theta:向量\\vec{a}和\\vec{b}之间的夹角，\\theta\\in[0,\\pi] a⋅b=∣a∣⋅∣b∣⋅cosθθ:向量a和b之间的夹角，θ∈[0,π] 向量点乘的正负号有重要意义： a⃗⋅b⃗=0：cosθ=0，θ=π2a⃗⋅b⃗&gt;0：cosθ&gt;0，θ∈[0,π2)a⃗⋅b⃗&lt;0：cosθ&lt;0，θ∈(π2,π]\\vec{a}\\cdot\\vec{b}=0：cos\\theta=0，\\theta=\\frac{\\pi}{2}\\\\ \\vec{a}\\cdot\\vec{b}&gt;0：cos\\theta&gt;0，\\theta\\in[0,\\frac{\\pi}{2})\\\\ \\vec{a}\\cdot\\vec{b}&lt;0：cos\\theta&lt;0，\\theta\\in(\\frac{\\pi}{2},\\pi] a⋅b=0：cosθ=0，θ=2π​a⋅b&gt;0：cosθ&gt;0，θ∈[0,2π​)a⋅b&lt;0：cosθ&lt;0，θ∈(2π​,π] 实际使用时，通常通过代数计算两向量的点乘结果，根据该结果的正负来做几何上的判断。 向量叉乘 两个向量叉乘的结果是一个向量，有以下两种算法。 代数 a⃗×b⃗=(0,0,x1y2−y1x2)\\vec{a}\\times\\vec{b}=(0,0,x_1y_2-y_1x_2) a×b=(0,0,x1​y2​−y1​x2​) 几何 a⃗×b⃗=(∣a⃗∣∣b⃗∣sinθ)n⃗\\vec{a}\\times\\vec{b}=(\\lvert\\vec{a}\\rvert\\lvert\\vec{b}\\rvert sin\\theta)\\vec{n}\\\\ a×b=(∣a∣∣b∣sinθ)n 模：∣a⃗×b⃗∣=∣a⃗∣⋅∣b⃗∣⋅sinθ\\lvert\\vec{a}\\times\\vec{b}\\rvert=\\lvert\\vec{a}\\rvert \\cdot \\lvert\\vec{b}\\rvert \\cdot sin\\theta\\\\∣a×b∣=∣a∣⋅∣b∣⋅sinθ 方向：为n⃗\\vec{n}n的方向，遵守右手螺旋法则，右手握拳，四指沿a⃗\\vec{a}a、b⃗\\vec{b}b环绕，则大拇指所指方向就是结果向量的方向。 点在左（右）侧时的向量叉乘区别 P在AB左侧时： AB⃗×AP⃗的方向垂直于纸面向外\\vec{AB}\\times\\vec{AP}的方向垂直于纸面向外 AB×AP的方向垂直于纸面向外 P在AB右侧时： AB⃗×AP⃗的方向垂直于纸面向里\\vec{AB}\\times\\vec{AP}的方向垂直于纸面向里 AB×AP的方向垂直于纸面向里 结论：P在AB左侧时，AB和AP向量叉乘的结果向量垂直纸面向外；P在右侧时，垂直纸面向内。 结合向量点乘进一步推导 前面已知，当两个向量的点乘结果大于零表明两个向量之间的角度不大于90°。 那么要判断一个向量是垂直纸面向外（向内），我们可以将该相连与（0,0,1）向量进行点乘，结果大于零表明垂直纸面向外，小于零表明垂直纸面向内。 z⃗=(0,0,1)(a⃗×b⃗)⋅z⃗=(0,0,x1y2−y1x2)⋅(0,0,1)=x1y2−y1x2\\vec{z}=(0,0,1)\\\\ (\\vec{a}\\times\\vec{b})\\cdot\\vec{z}=(0,0,x_1y_2-y_1x_2)\\cdot(0,0,1)=x_1y_2-y_1x_2 z=(0,0,1)(a×b)⋅z=(0,0,x1​y2​−y1​x2​)⋅(0,0,1)=x1​y2​−y1​x2​ 所以，判断平面内一个点位于有向线段的左侧还是右侧，其整体逻辑如下： x1y2−y1x2&gt;0:AB与AP叉乘结果，垂直纸面向外，P在AB左侧x1y2−y1x2&lt;0:AB与AP叉乘结果，垂直纸面向内，P在AB右侧x_1y_2-y_1x_2&gt;0:AB与AP叉乘结果，垂直纸面向外，P在AB左侧\\\\ x_1y_2-y_1x_2&lt;0:AB与AP叉乘结果，垂直纸面向内，P在AB右侧 x1​y2​−y1​x2​&gt;0:AB与AP叉乘结果，垂直纸面向外，P在AB左侧x1​y2​−y1​x2​&lt;0:AB与AP叉乘结果，垂直纸面向内，P在AB右侧","link":"/post/c2f0487512c3/"},{"title":"图形变换","text":"缩放、旋转和平移是图形的基本变化，从几何算法的角度看是统一的：都是借助变换向量实现。 本文针对这三种基本变换操作封装三个接口。值得注意的是，这三个接口都是针对实体本身，即使实体不存在数据库中也可以使用。 旋转 12345678public static Entity Rotate(this Entity entity, Point3d basePoint, double ratation){ if (entity == null) return null; Matrix3d mt = Matrix3d.Rotation(ratation, Vector3d.ZAxis, basePoint); Entity tempEntity = entity.Clone() as Entity; tempEntity.TransformBy(mt); return tempEntity;} 缩放 12345678public static Entity Scale(this Entity entity, Point3d basePoint, double scaleFactor){ if (entity == null) return null; Matrix3d mt = Matrix3d.Scaling(scaleFactor, basePoint); Entity tempEntity = entity.Clone() as Entity; tempEntity.TransformBy(mt); return tempEntity;} 平移 123456789public static Entity Move(this Entity entity, Point3d startPoint, Point3d endPoint){ if (entity == null) return null; Vector3d vector = startPoint.GetVectorTo(endPoint); Matrix3d mt = Matrix3d.Displacement(vector); Entity tempEntity = entity.Clone() as Entity; tempEntity.TransformBy(mt); return tempEntity;}","link":"/post/1b8b9c6eaa89/"},{"title":"增删实体","text":"增删实体是CAD二次开发最常见的操作，本文封装了4个最通用的实体增删函数。 添加单个实体 123456789101112131415161718192021222324252627282930public static ObjectId AddEntity(this Database db, Entity entity, string layoutName = null){ if (entity == null) return ObjectId.Null; ObjectId id = ObjectId.Null; using (var docLock = DwgOperators.ThisDocument.LockDocument()) { using (Transaction transaction = db.TransactionManager.StartTransaction()) { BlockTable bt = transaction.GetObject(db.BlockTableId, OpenMode.ForRead) as BlockTable; bool flag = true; ObjectId spaceId = ObjectId.Null; if (layoutName == null) spaceId = bt[BlockTableRecord.ModelSpace]; else { spaceId = GetLayoutIdByName(db, layoutName); if (spaceId == ObjectId.Null) flag = false; } if (flag) { BlockTableRecord btr = transaction.GetObject(spaceId, OpenMode.ForWrite) as BlockTableRecord; id = btr.AppendEntity(entity); transaction.AddNewlyCreatedDBObject(entity, true); } transaction.Commit(); } return id; }} 添加多个实体 123456789101112131415161718192021222324252627282930313233public static List&lt;ObjectId&gt; AddEntities&lt;T&gt;(this Database db, List&lt;T&gt; entities, string layoutName = null) where T : Entity{ List&lt;ObjectId&gt; ids = new List&lt;ObjectId&gt;(); ObjectId id = ObjectId.Null; using (Transaction transaction = db.TransactionManager.StartTransaction()) { BlockTable bt = transaction.GetObject(db.BlockTableId, OpenMode.ForRead) as BlockTable; bool flag = true; ObjectId spaceId = ObjectId.Null; if (layoutName == null) spaceId = bt[BlockTableRecord.ModelSpace]; else { spaceId = GetLayoutIdByName(db, layoutName); if (spaceId == ObjectId.Null) flag = false; } if (flag) { BlockTableRecord btr = transaction.GetObject(spaceId, OpenMode.ForWrite) as BlockTableRecord; foreach (Entity entity in entities) { id = btr.AppendEntity(entity); transaction.AddNewlyCreatedDBObject(entity, true); ids.Add(id); } } transaction.Commit(); } return ids;} 删除单个实体 1234567891011public static void DeleteEntity(this Database db, ObjectId id){ if (id == ObjectId.Null) return; using (Transaction transaction = db.TransactionManager.StartTransaction()) { var entity = transaction.GetObject(id, OpenMode.ForWrite, true); if (entity != null) entity.Erase(true); transaction.Commit(); }} 删除多个实体 1234567891011121314public static void DeleteEntities(this Database db, params ObjectId[] ids){ if (ids == null || ids.Count() == 0) return; using (Transaction transaction = db.TransactionManager.StartTransaction()) { foreach (ObjectId id in ids) { var entity = transaction.GetObject(id, OpenMode.ForWrite, true); if (entity != null) entity.Erase(true); } transaction.Commit(); }}","link":"/post/20c7e786f428/"},{"title":"外部参照","text":"外部参照在CAD绘图中也扮演着重要角色，设计人员经常将外部图纸作为参照载入当前图纸，用于比对图纸信息或成果组织。 本文针对外部参照，封装加载、卸载、删除、查询接口，卸载接口尤其值得注意。 加载外部参照 123456789101112public static ObjectId AttachXref(this Database db, string dwgPath, string xrefName, Point3d insertPoint){ ObjectId refId = db.AttachXref(dwgPath, xrefName); if (!refId.IsNull) { var blockRef = new BlockReference(insertPoint, refId); db.AddEntity(blockRef); DwgOperators.ThisEditor.UpdateScreen(); return blockRef.ObjectId; } return ObjectId.Null;} 卸载外部参照 注意：卸载外部参照时，最好一并删除，否则每次打开图形会提示外部参照未加载。 123456789101112131415161718192021222324252627282930313233343536373839404142public static bool UnloadXrefByName(this Database db, string xrefName){ bool flag = false; using (Transaction tran = db.TransactionManager.StartTransaction()) { BlockTable bt = tran.GetObject(db.BlockTableId, OpenMode.ForRead) as BlockTable; foreach (ObjectId id in bt) { BlockTableRecord btr = tran.GetObject(id, OpenMode.ForRead) as BlockTableRecord; if (btr.IsFromExternalReference &amp;&amp; btr.Name == xrefName) { db.UnloadXrefs(new ObjectIdCollection(new ObjectId[] { id })); db.DetachXref(id); flag = true; break; } } tran.Commit(); } DwgOperators.ThisEditor.UpdateScreen(); return flag;}public static bool SearchXrefByName(this Database db, string xrefName){ bool flag=false; using (Transaction tran = db.TransactionManager.StartTransaction()) { BlockTable bt = tran.GetObject(db.BlockTableId, OpenMode.ForRead) as BlockTable; foreach (ObjectId id in bt) { BlockTableRecord btr = tran.GetObject(id, OpenMode.ForRead) as BlockTableRecord; if (btr.IsFromExternalReference &amp;&amp; btr.Name == xrefName) { flag = true; break; } } tran.Commit(); } return flag;} 查询外部参照 12345678910111213141516171819202122public static void DeleteXrefs(this Database db){ if (db == null) return; using (Transaction tran = db.TransactionManager.StartTransaction()) { BlockTable bt = tran.GetObject(db.BlockTableId, OpenMode.ForWrite) as BlockTable; List&lt;ObjectId&gt; ids = new List&lt;ObjectId&gt;(); foreach (ObjectId id in bt) { BlockTableRecord btr = tran.GetObject(id, OpenMode.ForRead) as BlockTableRecord; if (btr.IsFromExternalReference) ids.Add(id); } foreach (ObjectId id in ids) { BlockTableRecord btr = tran.GetObject(id, OpenMode.ForWrite, true) as BlockTableRecord; if (btr != null) btr.Erase(); } tran.Commit(); }}","link":"/post/347c4ce2bceb/"},{"title":"布局和视口","text":"布局和视口是CAD出图的重要手段之一，其中视口可以映射到模型空间的任一范围，进而在布局空间灵活组织图形成果。 本文针对布局创建及切换、视口创建封装若干接口。 切换布局 借助Database的TileMode属性来切换到模型空间 12345678910111213141516171819202122232425262728293031323334353637383940414243public static void SwitchLayout(this Document doc, string layoutName){ if (string.IsNullOrWhiteSpace(layoutName) || ObjectId.Null == doc.Database.GetLayoutIdByName(layoutName)) return; using (var docLock = doc.LockDocument()) LayoutManager.Current.CurrentLayout = layoutName;}public static void SwitchToModel(){ var doc = DwgOperators.ThisDocument; using (var docLock = doc.LockDocument()) doc.Database.TileMode = true;}//----------------------------------------------------------------------private static ObjectId GetLayoutIdByName(this Database db, string layoutName){ ObjectId resId = ObjectId.Null; if (string.IsNullOrWhiteSpace(layoutName)) return resId; using (Transaction transaction = db.TransactionManager.StartTransaction()) { BlockTable blockTable = transaction.GetObject(db.BlockTableId, OpenMode.ForRead) as BlockTable; foreach (ObjectId id in blockTable) { BlockTableRecord btr = transaction.GetObject(id, OpenMode.ForRead) as BlockTableRecord; if (btr.IsLayout) { Layout layout = transaction.GetObject(btr.LayoutId, OpenMode.ForRead) as Layout; if (layout.LayoutName == layoutName) { resId = id; break; } } } transaction.Commit(); } return resId;} 创建布局 为了使新布局生效，调用SwitchLayout()切换一下。 1234567891011121314151617181920public static ObjectId CreateLayout(this Document doc, string layoutName){ ObjectId resId = ObjectId.Null; if (doc == null || string.IsNullOrWhiteSpace(layoutName)) return resId; var db = doc.Database; if (db.GetLayoutIdByName(layoutName) != ObjectId.Null) return resId; using (var docLock = doc.LockDocument()) { using (Transaction transaction = doc.TransactionManager.StartTransaction()) { DBDictionary layouts = transaction.GetObject(db.LayoutDictionaryId, OpenMode.ForWrite) as DBDictionary; resId = LayoutManager.Current.CreateLayout(layoutName); transaction.Commit(); } } doc.Database.SwitchLayout(layoutName); return resId;} 创建视口 创建从任一矩形创建视口的函数，此函数的开发着实花费了不少精力，感叹一下！ CreateViewportIntoPaperspace()：创建模型空间中任一矩形的视口（很实用） SetViewportLockedLayers()：设置某一视口中的图层状态 AddUCS()：添加用户坐标系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public static ObjectId CreateViewportIntoPaperspace(this Database db,string layoutName, Point3d leftBottomPoint, double width, double height,double rotation, Point3d viewportLeftBottomPoint, double? viewportWidth = null,double? viewportHeight = null, double scale = 1.0){ ObjectId resId = ObjectId.Null; if (string.IsNullOrWhiteSpace(layoutName)) return resId; using (Transaction transaction = db.TransactionManager.StartTransaction()) { Viewport vport = new Viewport(); double vWidth, vHeight; if (viewportWidth == null) vWidth = width; else vWidth = viewportWidth.Value; if (viewportHeight == null) vHeight = height; else vHeight = viewportHeight.Value; vport.CenterPoint = new Point3d(viewportLeftBottomPoint.X + 0.5 * vWidth, viewportLeftBottomPoint.Y + 0.5 * vHeight, 0); vport.Width = vWidth; vport.Height = vHeight; var point = CoorTransform(leftBottomPoint, rotation, new Point3d(0.5 * width, 0.5 * height, 0)); vport.ViewTarget = point; var ucsId = db.AddUCS($&quot;ucs-{Guid.NewGuid().ToString()}&quot;, leftBottomPoint, new Vector3d(Math.Cos(rotation), Math.Sin(rotation), 0), new Vector3d(Math.Cos(rotation + 0.5 * Math.PI), Math.Sin(rotation + 0.5 * Math.PI), 0)); vport.SetUcs(ucsId); vport.TwistAngle = Math.PI * 2 - rotation; vport.ViewDirection = new Vector3d(0, 0, 1); vport.CustomScale = scale; resId = db.AddEntity(vport, layoutName); db.SwitchLayout(layoutName); vport.On = true; transaction.Commit(); } return resId;}public static void SetViewportLockedLayers(this Document doc, ObjectId id, List&lt;string&gt; frozenLayerNames){ if (doc == null || id == ObjectId.Null) return; if (frozenLayerNames == null || frozenLayerNames.Count == 0) return; var db = doc.Database; using (Transaction transaction = db.TransactionManager.StartTransaction()) { Viewport vp = transaction.GetObject(id, OpenMode.ForWrite) as Viewport; if (vp != null) { LayerTable lt = transaction.GetObject(db.LayerTableId, OpenMode.ForRead) as LayerTable; List&lt;ObjectId&gt; layerIds = new List&lt;ObjectId&gt;(); foreach (var name in frozenLayerNames) if (lt.Has(name)) layerIds.Add(lt[name]); vp.FreezeLayersInViewport(layerIds.GetEnumerator()); } transaction.Commit(); }}//----------------------------------------------------------------------private static ObjectId AddUCS(this Database db, string ucsName, Point3d origin, Vector3d xAxis, Vector3d yAxis){ ObjectId resId = ObjectId.Null; if (string.IsNullOrWhiteSpace(ucsName)) return resId; using (Transaction transaction = db.TransactionManager.StartTransaction()) { UcsTable ucsTable = transaction.GetObject(db.UcsTableId, OpenMode.ForWrite) as UcsTable; if (!ucsTable.Has(ucsName)) { UcsTableRecord ucsTableRecord = new UcsTableRecord(); ucsTableRecord.Name = ucsName; ucsTableRecord.Origin = origin; ucsTableRecord.XAxis = xAxis; ucsTableRecord.YAxis = yAxis; resId = ucsTable.Add(ucsTableRecord); transaction.AddNewlyCreatedDBObject(ucsTableRecord, true); ucsTable.DowngradeOpen(); } else resId = ucsTable[ucsName]; transaction.Commit(); } return resId;}private static Point3d CoorTransform(Point3d deltaDist, double rotation, Point3d p1){ double dist1 = Math.Sqrt(p1.X * p1.X + p1.Y * p1.Y); double rotation1 = Arctan(p1.Y, p1.X); double totalRotation = rotation1 + rotation; Point3d resPoint = new Point3d(deltaDist.X + dist1 * Math.Cos(totalRotation), deltaDist.Y + dist1 * Math.Sin(totalRotation), 0); return resPoint;}","link":"/post/f3a8f2326720/"},{"title":"实体颜色修改","text":"颜色修改在CAD中属于比较简单的操作，但是当面临块嵌套的情况时，要想彻底修改其颜色可能会非常困难。 本文聚集在修改嵌套块的颜色上，封装相关接口。 递归修改块中元素的颜色模式 将块中所有元素的颜色模式修改为ByBlock模式，最后修改块参照颜色即可实现，这里使用到递归算法。 123456789101112131415161718public static void SetBlockEntitiesColor(this Document doc, BlockReference block){ using (Transaction trans = doc.TransactionManager.StartTransaction()) { BlockTableRecord btr = trans.GetObject(block.BlockTableRecord, OpenMode.ForRead) as BlockTableRecord; foreach (ObjectId id in btr) { Entity ent2 = (Entity)trans.GetObject(id, OpenMode.ForWrite); ent2.ColorIndex = 0; if (ent2 is BlockReference) { BlockReference block1 = (BlockReference)ent2; SetBlockEntitiesColor(doc, block1); } } trans.Commit(); }} 修改块参照颜色 123456public static void ChangeBlockReferenceColor(this Document doc, BlockReference block, System.Windows.Media.Color blockColor){ SetBlockEntitiesColor(doc, block); cadColors.Color color = cadColors.Color.FromRgb(blockColor.R, blockColor.G, blockColor.B); block.Color = color;}","link":"/post/4555870c9ae9/"},{"title":"形式与内容","text":"知识必须结构化；学习是一个“由少至多，从多到少”的过程。 形式与内容 越来越觉得，要想熟练掌握一门知识或技能，形式和内容都至关重要。 要么先有零散内容，后总结归纳形成系统框架； 要么先有框架，再向框架中填充内容。 总之，知识必须结构化。 全面与重点 如同框架和内容的关系，“全面”是指框架要成系统；但学习具体内容时，应抓住重点，因为这才是能力提升的瓶颈所在。 对于过于简单的知识点，不在框架中分节发散，以减少形式上的繁琐； 对于重点且有难度的知识点，应集中火力突破，并通过理解的逐渐加深，最终将其转化为简单知识点。 因此，我推荐的学习方法是，先搭建整体知识框架，对重点和难点进行形式上的扩展，通过不断加深理解，将其转变为简单知识点，并进行形式上的简化，简而言之“由少至多，从多到少”。","link":"/post/1da2a57de0de/"},{"title":"扩展数据","text":"CAD二次开发中，当需要对图形做某种持久化标记时，就需要用到扩展数据；同时，扩展数据与DXF文件拥有相同的组织方式，在某些情况下可用于修改图形属性。 本文针对扩展数据封装若干常用的二次开发接口。 添加扩展数据 扩展数据必须与某个注册应用名绑定在一起，因此添加扩展数据之前要创建相应的注册应用，初次接触会觉得很奇怪！ 123456789101112131415161718192021222324252627public static void AppendXData(this ObjectId id, string regAppName, List&lt;TypedValue&gt; values){ var db = id.Database; using (DocumentLock docLock = DwgOperators.ThisDocument.LockDocument()) { using (Transaction transaction = db.TransactionManager.StartTransaction()) { RegAppTable regAppTable = db.RegAppTableId.GetObject(OpenMode.ForWrite) as RegAppTable; if (!regAppTable.Has(regAppName)) { RegAppTableRecord regAppTableRecord = new RegAppTableRecord(); regAppTableRecord.Name = regAppName; regAppTable.Add(regAppTableRecord); db.TransactionManager.AddNewlyCreatedDBObject(regAppTableRecord, true); } DBObject obj = id.GetObject(OpenMode.ForWrite); values.Insert(0, new TypedValue((int)DxfCode.ExtendedDataRegAppName, regAppName)); ResultBuffer resultBuffer = new ResultBuffer(); foreach (var item in values) resultBuffer.Add(item); obj.XData = resultBuffer; regAppTable.DowngradeOpen(); transaction.Commit(); } }} 移除扩展数据 123456789101112131415161718public static void RemoveXData(this ObjectId id, string regAppName){ Database db = id.Database; using (Transaction transaction = db.TransactionManager.StartTransaction()) { DBObject obj = id.GetObject(OpenMode.ForWrite); ResultBuffer rb = obj.GetXDataForApplication(regAppName); if (rb != null) { ResultBuffer resultBuffer = new ResultBuffer(); resultBuffer.Add(new TypedValue((int)DxfCode.ExtendedDataRegAppName, regAppName)); obj.XData = resultBuffer; } obj.DowngradeOpen(); transaction.Commit(); }} 获取扩展数据 123456789public static List&lt;TypedValue&gt; GetXData(this ObjectId id, string regAppName){ List&lt;TypedValue&gt; values = new List&lt;TypedValue&gt;(); DBObject obj = id.GetObject(OpenMode.ForRead); var res = obj.GetXDataForApplication(regAppName); foreach (var item in res) values.Add(new TypedValue(item.TypeCode, item.Value)); return values;} 为实体绑定信息 可以借助扩展数据机制为图元绑定持久化信息，接口实现如下所示： 1234567891011121314public static void AttachEntityInfo(this ObjectId id, List&lt;Tuple&lt;string, string&gt;&gt; blockInfos){ Database db = id.Database; using (Transaction transaction = db.TransactionManager.StartTransaction()) { foreach (var item in blockInfos) { List&lt;TypedValue&gt; values = new List&lt;TypedValue&gt;(); values.Add(new TypedValue((int)DxfCode.ExtendedDataAsciiString, item.Item2)); AddXData(id, item.Item1, values); } transaction.Commit(); }}","link":"/post/3f69b07ca04f/"},{"title":"排序算法(1)","text":"排序算法在整个算法体系中属于比较基础的知识，以致于大多数人并没有意识到它对于构建当今计算机庞大技术体系所发挥的巨大作用。 对于很多算法问题而言，要想直接找到更小时间复杂度的方案非常困难，但是一旦将数据排好序，问题就会迎刃而解，所以排序算法扮演着算法基石的作用。 计算机科学家们很早就开始研究各种排序算法，排序算法时间复杂度的每一次微小降低，都会在计算机世界引起轰动。 概述 分类 内排序 &amp; 外排序：待排序数据是否都在内存中 原址排序 &amp; 非原址排序：是否需要辅助空间（允许常量辅助空间，比如交换元素时的辅助变量） 稳定排序 &amp; 非稳定排序：相等的数在在排序后相对位置是否会发生变化 比较排序 &amp; 非比较排序：比较排序最好的时间复杂度是O(nlogn) 具体算法 排序算法很多，大家谈论比较多的、也是学生时代必学的排序算法主要有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、堆排序、快速排序、计数排序、基数排序、桶排序等。本文会对它们一一介绍。 当今世界，数据量呈现爆炸式增长，外部排序能有效解决超大规模数据的排序问题，有必要一窥其究竟。 在经典语言标准库中，排序并不是简单使用上述某种方案，更多是结合多种排序算法的优点改造形成，本文也会对这进行适当扩展。 时间复杂度O(n2) 冒泡排序 冒泡排序是最直观的排序方式，存在若干优化： 如果一趟下来没有发生元素交换，则说明数组有序，停止排序。 最后没有发生交换的元素是有序的，不用在下一趟比较重进行元素交换。 可以同时进行顺向和逆向的对比交换，以解决不对称的局部无序情况。 以下代码仅展示第一步优化。 12345678910111213141516171819void BubbleSort(int data[], int n) { if (n == 1) return; for (int i = 0; i &lt;= n - 2; i++) { // 定义一个布尔类型的标识符，指示数组是否有序 int flag = 1; for (int j = 0; j &lt;= n - 2 - i; j++) { if (data[j] &gt; data[j + 1]) { int temp = data[j]; data[j] = data[j + 1]; data[j + 1] = temp; // 一旦有交换说明数组可能无序 if (flag == 1) flag = 0; } } // 如果有序则不进行接下来的换位 if (flag) break; }} 选择排序 选择排序每次选择未排序元素的最小者，交换到前面。 12345678910111213void SelectSort(int data[], int n) { for (int i = 0; i &lt; n - 1; i++) { int index = i; for (int j = i + 1; j &lt; n; j++) if (data[j] &lt; data[index]) index = j; if (index != i) { int temp = data[index]; data[index] = data[i]; data[i] = temp; } }} 插入排序 插入排序每次将未排序元素的第一个向前插入到合适的位置。 1234567891011void InsertSort(int data[], int n) { for (int i = 1; i &lt; n; i++) { if (data[i] &gt;= data[i - 1]) continue; int temp = data[i]; int j; for (j = i - 1; j &gt;= 0 &amp;&amp; temp &lt; data[j]; j--) data[j + 1] = data[j]; data[j + 1] = temp; }} 时间复杂度O(nlogn)~O(n2) 希尔排序 希尔排序基于一个增量数组（增量数组的最后一个元素是1），每一个增量都对应一趟插入排序。 增量序列选取非常关键，理论上最后一个增量为1的序列都可以，希尔增量比较简单，增量元素依次折半，本文采用该方法。 很多研究给出了高效希尔排序的增量序列，主要有Hibbard增量和Sedgewick增量，后者的时间复杂度更小。 12345678910111213141516171819202122232425void ShellSort(int data[], int n) { // 求shell序列 int *delta = (int*)malloc(sizeof(int) * (n / 2)); int k = n; int i = 0; while (k &gt; 0) { k /= 2; delta[i++] = k; } i = 0; int dk; while ((dk = delta[i++]) &gt; 0) { for (k = dk; k &lt; n; ++k) { if (data[k] &gt;= data[k - dk]) continue; int t = data[k]; int j; for (j = k - dk; j &gt;= 0 &amp;&amp; t &lt; data[j]; j -= dk) data[j + dk] = data[j]; data[j + dk] = t; } } // 释放增量数组 free(delta);} 时间复杂度O(nlogn) 归并排序 归并排序基于分治思想，每次将数组从中间划分成两个数组，将两个数组分别排序后再合并成一个有序数组。 核心算法：两个有序数组的归并，需要依赖一个同等大小的临时数组。 12345678910111213141516171819202122232425262728void MSort(int data[], int left, int right) { if (left &gt;= right) return; int n = right - left + 1; int center = (left + right) / 2; MSort(data, left, center); MSort(data, center + 1, right); // 两个有序数组的合并（以下是最容易理解的方式） int *tempArray = (int*)malloc(sizeof(int) * n); int l = left, r = center + 1; for (int i = 0; i &lt; n; i++) { if (l &gt; center) tempArray[i] = data[r++]; else if (r &gt; right) tempArray[i] = data[l++]; else if (data[l] &lt; data[r]) tempArray[i] = data[l++]; else tempArray[i] = data[r++]; } free(tempArray);}void MergeSort(int data[], int n) { if (n &lt;= 1) return; MSort(data, 0, n - 1);} 堆排序 堆排序基于大根堆（或小根堆）的数据结构。构建堆、堆序破坏后修复（新增元素、删除根元素）是堆的三种核心操作，这三种操作依赖单个元素或多个元素的下沉操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 下沉操作void Sink(int data[], int n, int index) { if (index &lt; 0 || index &gt;= n) return; for (int j = index; 2 * j + 1 &lt; n;) { // 有左、右儿子 if (2 * j + 2 &lt; n) { if (data[j] &gt;= data[2 * j + 1] &amp;&amp; data[j] &gt;= data[2 * j + 2]) break; if (data[2 * j + 1] &gt;= data[2 * j + 2] ) { swap(&amp;data[2 * j + 1], &amp;data[j]); j = 2 * j + 1; } else { swap(&amp;data[2 * j + 2], &amp;data[j]); j = 2 * j + 2; } } // 只有左儿子 else { if (data[j] &lt; data[2 * j + 1]) swap(&amp;data[2 * j + 1], &amp;data[j]); // 这是关键，容易疏忽 j = 2 * j + 1; } }}// 构建大根堆（升序排序）void BuildHeap(int data[], int n) { // 对所有非叶节点逆序进行下滤操作 for (int i = (n - 2) / 2; i &gt;= 0; i--) Sink(data, n, i);}void HeapSort(int data[], int n) { // 构建大根堆 BuildHeap(data, n); // 开始排序 for (int i = n - 1; i &gt; 0; i--) { swap(&amp;data[0], &amp;data[i]); Sink(data, i, 0); }} 从感性角度理解下沉和上浮操作，是深入掌握堆这种数据结构的关键： 从无序数组构建堆时，对非叶节点进行逆序下沉，从而保证每一条根到叶的路径都是有序的，这里等同于多路插入排序。 当堆有序时，如果破坏了堆序，就需要进行恢复。通用情况是，任何一个元素发生了变化，视其大小进行上浮和下沉即可恢复。 快速排序 快速排序基于分治思想，对一个数组排序时先选择一个枢纽元，按照该枢纽元将数组分成两部分；再采用相同的方式对两部分进行排序。 核心算法：基于枢纽元的数组分割。 1234567891011121314151617181920212223242526272829303132333435363738394041void QSort(int data[], int left, int right) { int n = right - left + 1; if (n &lt;= 1) return; if (n == 2) { if (data[left] &gt; data[right]) swap(&amp;data[left], &amp;data[right]); return; } // 计算枢轴元，采用三值取中值的方式 int center = (left + right) / 2; if (data[left] &gt; data[center]) swap(&amp;data[left], &amp;data[center]); if (data[left] &gt; data[right]) swap(&amp;data[left], &amp;data[right]); if (data[center] &gt; data[right]) swap(&amp;data[center], &amp;data[right]); swap(&amp;data[center], &amp;data[right - 1]); int pivot = data[right - 1]; // 数组分割 int l = left; int r = right - 1; while (1) { while (data[++l] &lt; pivot) {} while (data[--r] &gt; pivot) {} if (l &lt; r) swap(&amp;data[l], &amp;data[r]); else break; } swap(&amp;data[l], &amp;data[right - 1]); // 对划分的两个子数组进行排序 QSort(data, left, l - 1); QSort(data, l + 1, right);}void QuickSort(int data[], int n) { QSort(data, 0, n - 1);}","link":"/post/2a91adc453fe/"},{"title":"文档操作","text":"CAD常用文件操作包括：创建图形文件、打开图形文件、判断文件是否保存和保存文件，后两者值得重点注意。 创建、打开文档 创建文档需要指定dwt模板 123456789101112131415public static string CreateNewDwg(){ string dllPath = System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location); string templatePath = dllPath + @&quot;\\acadiso.dwt&quot;; Document doc = AcadApp.DocumentManager.Add(templatePath); AcadApp.DocumentManager.MdiActiveDocument = doc; return doc.Name;}public static void OpenDwg(string filename, bool forReadOnly = false){ var docs = AcadApp.DocumentManager; Document doc = docs.Open(filename, forReadOnly); docs.MdiActiveDocument = doc;} 检测图形是否已保存 利用&quot;DBMOD&quot;环境变量实现 1234567public static bool Saved(this Document doc){ object dbmod = AcadApp.GetSystemVariable(&quot;DBMOD&quot;); if (Convert.ToInt16(dbmod) != 0) return false; return true;} 保存文档 保存文档的相关接口包括以下4个： doc.CloseAndSave(string path) doc.CloseAndDiscard() db.SaveAs(string path,DwgVersion.Current) db.Save() 前三个接口使用时应注意： 对于激活文档：使用CloseAndSave()、CloseAndDiscard()时，要为命令方法添加CommandFlag.Session声明，不然会报以下错误 对于非激活文档：使用CloseAndSave()、CloseAndDiscard()时，不添加CommandFlag.Session声明 SaveAs()：适用于激活文档和非激活文档，不需要添加CommandFlag.Session声明 Save()：未实现，无法使用，会报以下错误","link":"/post/89ed5af22533/"},{"title":"结构型设计模式","text":"本文简要介绍7种类结构型设计模式。 适配器（Adapter） 适配器模式，强调将一个既有类”改造“成目标类型，这种”改造“不是重构，而是添加适配器，在适配器方法（与目标类型同）中调用既有类的功能，实现间接”改造“。 适配器有两种实现方法，多重继承和对象组合，前者只支持适配一个具体的类，后者允许适配既有类或其子类。根据实际场景选择最佳方案。 类适配器 采用类的多重继承实现： 对象适配器 采用对象组合来实现： 代理（Proxy） 代理模式，强调为既有类提供一种代理，以控制对既有类实例的访问。 享元（Flyweight） 享元模式，强调将一个类中的状态划分为内部状态和外部状态两类，以参数形式传入外部状态，从而归并类实例减小运行内存消耗。 组合（Composite） 组合模式，强调单个对象和组合对象的接口一致性，适合定义树形结构。 装饰（Decorator） 装饰模式，强调给一个对象添加一些额外职责。.NET Framework中的IO流深度使用了该设计模式。 外观（Facade） 外观模式，强调对客户屏蔽子系统组件，从而实现子系统与客户之间的松耦合关系。 桥接（Bridge） 桥接模式，强调抽象部分与实现部分分离，特别适合脱平台开发。","link":"/post/0357a3cc394c/"},{"title":"绘制三点圆弧","text":"问题：提供圆弧两端点和弧上一点，编程绘制三点圆弧？ 关键：如何求解创建圆弧时的角度顺序，保证圆弧经过指定的弧上点。 步骤 确定圆心和半径 分别求两端点及弧上点与圆心连线的角度∠1、∠2、∠3（转换为0~2π范围） 取∠1&lt;∠2 判断∠3是否在∠1→∠2之间 如果是，绘制∠1→∠2圆弧，否则绘制∠2→∠1圆弧 细节 三点互异 三点不共线 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/// &lt;summary&gt;/// 三点创建圆弧/// &lt;/summary&gt;/// &lt;param name=&quot;endPoint1&quot;&gt;圆弧端点之一&lt;/param&gt;/// &lt;param name=&quot;endPoint2&quot;&gt;圆弧端点之一&lt;/param&gt;/// &lt;param name=&quot;pointOnArc&quot;&gt;弧上一点&lt;/param&gt;/// &lt;returns&gt;创建的圆弧&lt;/returns&gt;public static Arc CreateArcByThreePoints(Point3d endPoint1, Point3d endPoint2, Point3d pointOnArc) { if (endPoint1 == endPoint2 || endPoint2 == pointOnArc || pointOnArc == endPoint1 || AreThreePointsOnLine(endPoint1, endPoint2, pointOnArc)) return null; CircularArc3d circle = new CircularArc3d(endPoint1, pointOnArc, endPoint2); double R = circle.Radius; Point3d center = circle.Center; double angle1 = Math.Atan2(endPoint1.Y - center.Y, endPoint1.X - center.X); if (angle1 &lt; 0) angle1 += Math.PI * 2; double angle2 = Math.Atan2(endPoint2.Y - center.Y, endPoint2.X - center.X); if (angle2 &lt; 0) angle1 += Math.PI * 2; double angle3 = Math.Atan2(pointOnArc.Y - center.Y, pointOnArc.X - center.X); if (angle3 &lt; 0) angle1 += Math.PI * 2; if (angle1 &lt; angle2) { double temp = angle1; angle1 = angle2; angle2 = temp; } Arc arc = new Arc(center, R, angle2, angle1); if (angle3 &gt; angle1 &amp;&amp; angle3 &lt; angle2) arc = new Arc(center, R, angle1, angle2); return arc;}/// &lt;summary&gt;/// 判断三点是否共线/// &lt;/summary&gt;/// &lt;param name=&quot;p1&quot;&gt;点1&lt;/param&gt;/// &lt;param name=&quot;p2&quot;&gt;点2&lt;/param&gt;/// &lt;param name=&quot;p3&quot;&gt;点3&lt;/param&gt;/// &lt;returns&gt;共线返回true，否则返回false&lt;/returns&gt;public static bool AreThreePointsOnLine(Point3d p1, Point3d p2, Point3d p3) { Vector2d v13 = new Vector2d(p3.X - p1.X, p3.Y - p1.Y); Vector2d v23 = new Vector2d(p3.X - p2.X, p3.Y - p2.Y); return v13.IsParallelTo(v13);}","link":"/post/580edc27fe69/"},{"title":"给既有exe程序添加一机一码验证","text":"本科期间开发过一款混凝土基本构件设计程序，该程序是一个独立的exe可执行文件，采用VC++静态链接MFC库编制而成。近期，需要为该程序添加用户注册验证的功能，从而避免任何用户获取该程序就能无限制使用的问题。 刚开始，打算在网络上找可直接为单个exe文件添加“一机一码”注册功能的平台软件，但该类软件基本都是付费软件，且生成的加壳程序很容易被杀毒软件误差。好在“一机一码”机制并不复杂，最终决定使用C#编程的方式手动实现该功能。 整体思路 新建C#控制台程序，将exe嵌入C#的资源文件 控制台程序启动后，先进行“一机一码”校验： 如果已注册，直接进入第3步 如果未注册，则弹出注册窗口，提示用户输入注册码：注册成功进入第3步；失败继续提示输入注册码或退出 通过代码从资源文件中释放exe，并启动新进程，控制台进程等待新进程执行完毕再退出 主要问题 “一机一码”的验证策略 先获取硬件（CPU、硬盘等）的序列号，通过序列号组合成机器码 通过某种加密算法从机器码计算得到注册码，并把注册码写入特定的文件或注册表 每次打开加壳程序时，都先获取机器码计算注册码，将计算得到的注册码与保存在本地的注册码进行比较，如果一致就说明注册成功，反之失败 以下是获取CPU和硬盘序列号的函数： 123456789101112131415161718192021222324252627public static string GetCPUId() { try { ManagementObjectCollection collection1 = new ManagementClass(&quot;Win32_Processor&quot;).GetInstances(); string strCpuID = null; foreach (ManagementObject obj1 in collection1) { strCpuID = obj1.Properties[&quot;ProcessorId&quot;].Value.ToString(); break; } return strCpuID; } catch { return &quot;strCpuID&quot;; }}public static string GetDiskId() { try { ManagementObjectSearcher searcher = new ManagementObjectSearcher(&quot;SELECT * FROM Win32_PhysicalMedia&quot;); String strHardDiskID = null; foreach (ManagementObject mo in searcher.Get()) { strHardDiskID = mo[&quot;SerialNumber&quot;].ToString().Trim(); break; } return strHardDiskID; } catch { return &quot;strHardDiskID&quot;; }} 释放资源获得原始文件 这里需要指定释放文件的保存路径，可以选择当前用户的临时文件夹 可以设置释放文件的状态为隐藏，为用户拷贝该文件制造额外障碍 123456789101112byte[] fileBytes = Resource1.program;string fileName = System.IO.Path.GetTempPath();if (fileName.EndsWith(&quot;\\\\&quot;)) fileName = fileName + &quot;program.exe&quot;;else fileName = fileName + &quot;\\\\program.exe&quot;;using (BinaryWriter bw = new BinaryWriter(new System.IO.FileStream(fileName, System.IO.FileMode.Create))) { bw.Write(fileBytes); bw.Flush(); bw.Dispose();}File.SetAttributes(fileName, FileAttributes.Hidden); 执行释放程序并等待其结束 12System.Diagnostics.Process myPro = System.Diagnostics.Process.Start(fileName);myPro.WaitForExit(); 注意事项 释放exe文件后，该文件必定存在于本机某个路径，高级用户可以找到该路径并拷贝exe文件，从而轻松破解。这是本方法的硬伤，只能通过选择隐蔽路径、设置文件隐藏等方法加大定位该文件的难度。 由于采用C#语言进行加壳，很容易反编译得到加壳逻辑，这样从机器码到注册码的算法逻辑就非常容易被破解者发现，从而自己计算实现注册。解决该方法的办法是：使用C+ +编写机器码到注册码的算法逻辑，然后封装给C#程序调用；或者使用C+ +来进行加壳；或者更彻底一些，将注册码计算过程部署到服务器，通过网络来进行验证。 软件开发者端需要额外的注册码计算程序，从而实现软件分发控制。","link":"/post/0360a719e2ca/"},{"title":"自制WPF多线程加载框","text":"在实际项目中，有些后台操作耗时较久，这时前台最好有一个动画加载框给用户提示。 该加载框的动画显示和后台操作需要同时进行，因此需要采用多线程的方式进行实现。 UI界面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;Window x:Class=&quot;TestWPF.LoadingBar&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:TestWPF&quot; mc:Ignorable=&quot;d&quot; ResizeMode=&quot;NoResize&quot; WindowStyle=&quot;None&quot; WindowStartupLocation=&quot;CenterScreen&quot; Background=&quot;#E0E0E0&quot; SizeToContent=&quot;WidthAndHeight&quot; MaxWidth=&quot;200&quot;&gt; &lt;StackPanel Orientation=&quot;Vertical&quot;&gt; &lt;StackPanel.Resources&gt; &lt;Style x:Key=&quot;rec&quot; TargetType=&quot;Rectangle&quot;&gt; &lt;Setter Property=&quot;Width&quot; Value=&quot;13&quot;/&gt; &lt;Setter Property=&quot;Height&quot; Value=&quot;30&quot;/&gt; &lt;Setter Property=&quot;Margin&quot; Value=&quot;4,0&quot;/&gt; &lt;Setter Property=&quot;Fill&quot; Value=&quot;#f1404b&quot;/&gt; &lt;/Style&gt; &lt;PowerEase x:Key=&quot;powerEase&quot; Power=&quot;3&quot; EasingMode=&quot;EaseInOut&quot;/&gt; &lt;/StackPanel.Resources&gt; &lt;StackPanel.Triggers&gt; &lt;EventTrigger RoutedEvent=&quot;Loaded&quot;&gt; &lt;BeginStoryboard&gt; &lt;Storyboard RepeatBehavior=&quot;Forever&quot; Storyboard.TargetProperty=&quot;Height&quot;&gt; &lt;DoubleAnimation Storyboard.TargetName=&quot;rec1&quot; To=&quot;55&quot; BeginTime=&quot;0:0:0.0&quot; Duration=&quot;0:0:0.2&quot; EasingFunction=&quot;{StaticResource powerEase}&quot; AutoReverse=&quot;True&quot;/&gt; &lt;DoubleAnimation Storyboard.TargetName=&quot;rec2&quot; To=&quot;55&quot; BeginTime=&quot;0:0:0.1&quot; Duration=&quot;0:0:0.2&quot; EasingFunction=&quot;{StaticResource powerEase}&quot; AutoReverse=&quot;True&quot;/&gt; &lt;DoubleAnimation Storyboard.TargetName=&quot;rec3&quot; To=&quot;55&quot; BeginTime=&quot;0:0:0.2&quot; Duration=&quot;0:0:0.2&quot; EasingFunction=&quot;{StaticResource powerEase}&quot; AutoReverse=&quot;True&quot;/&gt; &lt;DoubleAnimation Storyboard.TargetName=&quot;rec4&quot; To=&quot;55&quot; BeginTime=&quot;0:0:0.3&quot; Duration=&quot;0:0:0.2&quot; EasingFunction=&quot;{StaticResource powerEase}&quot; AutoReverse=&quot;True&quot;/&gt; &lt;DoubleAnimation Storyboard.TargetName=&quot;rec5&quot; To=&quot;55&quot; BeginTime=&quot;0:0:0.4&quot; Duration=&quot;0:0:0.2&quot; EasingFunction=&quot;{StaticResource powerEase}&quot; AutoReverse=&quot;True&quot;/&gt; &lt;DoubleAnimation Storyboard.TargetName=&quot;rec6&quot; To=&quot;55&quot; BeginTime=&quot;0:0:0.5&quot; Duration=&quot;0:0:0.2&quot; EasingFunction=&quot;{StaticResource powerEase}&quot; AutoReverse=&quot;True&quot;/&gt; &lt;/Storyboard&gt; &lt;/BeginStoryboard&gt; &lt;/EventTrigger&gt; &lt;/StackPanel.Triggers&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot; Height=&quot;60&quot;&gt; &lt;Rectangle x:Name=&quot;rec1&quot; Style=&quot;{StaticResource rec}&quot;/&gt; &lt;Rectangle x:Name=&quot;rec2&quot; Style=&quot;{StaticResource rec}&quot;/&gt; &lt;Rectangle x:Name=&quot;rec3&quot; Style=&quot;{StaticResource rec}&quot;/&gt; &lt;Rectangle x:Name=&quot;rec4&quot; Style=&quot;{StaticResource rec}&quot;/&gt; &lt;Rectangle x:Name=&quot;rec5&quot; Style=&quot;{StaticResource rec}&quot;/&gt; &lt;Rectangle x:Name=&quot;rec6&quot; Style=&quot;{StaticResource rec}&quot;/&gt; &lt;/StackPanel&gt; &lt;TextBlock Text=&quot;{Binding Prompt}&quot; FontWeight=&quot;Bold&quot; Margin=&quot;0,2&quot; TextWrapping=&quot;Wrap&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Grid.ColumnSpan=&quot;3&quot; Grid.Row=&quot;1&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后台代码 后台代码是本窗体的重点，涉及到很多编程技巧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102using System;using System.ComponentModel;using System.Runtime.CompilerServices;using System.Threading;using System.Windows;namespace TestWPF { public partial class LoadingBar : Window, INotifyPropertyChanged { private LoadingBar() { InitializeComponent(); // 不在任务栏上显示，防止用户手动关闭 ShowInTaskbar = false; // 设置界面提示语 DataContext = this; Topmost = true; } /// &lt;summary&gt; /// 静态加载框实例 /// &lt;/summary&gt; private static LoadingBar instance = null; /// &lt;summary&gt; /// 防止多线程同时显示加载框，上锁 /// &lt;/summary&gt; private static object loadingBarLock = new object(); /// &lt;summary&gt; /// 设置标识符，防止多次关闭加载框 /// 初始值设置为true，可以防止用户最开始执行CloseLoadingBar()方法出错 /// &lt;/summary&gt; private static bool isClosed = true; #region 静态方法 public static void ShowLoadingbar(string prompt = &quot;处理中...&quot;) { isClosed = false; Thread thread = new Thread(() =&gt; { // 尝试获取锁 bool lockTaken = false; Monitor.TryEnter(loadingBarLock, 1000, ref lockTaken); // 获取锁成功，显示加载框 if (lockTaken) { if (instance == null) // 必须在此初始化，否则会报错 instance = new LoadingBar(); instance.Prompt = prompt; instance.ShowDialog(); // 窗体关闭，释放锁 Monitor.Exit(loadingBarLock); } }); thread.SetApartmentState(ApartmentState.STA); thread.Start(); } public static void SetPrompt(string prompt = &quot;处理中...&quot;) { if (instance != null) instance.Prompt = prompt; } /// &lt;summary&gt; /// 防止后台线程一直执行，调用此函数彻底关闭后台线程 /// &lt;/summary&gt; public static void CloseLoadingBar() { if (isClosed) return; // 加循环，保证执行CloseLoadingBar()完成后能成功关闭窗体（***） while (true) { if (instance != null &amp;&amp; instance.IsVisible) { instance.Dispatcher.Invoke(() =&gt; { instance.Close(); instance = null; isClosed = true; }); return; } } } #endregion #region 定义可通知UI的属性 private String _prompt; public string Prompt { get { return _prompt; } set { if (_prompt != value) { _prompt = value; OnPropertyChanged(); } } } public event PropertyChangedEventHandler PropertyChanged; private void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } #endregion }} 效果 LoadingBar.ShowLoadingbar()可以显示加载框，且可以传入参数，用来设置加载框的提示语。 LoadingBar.SetPrompt()可以设置提示语。 LoadingBar.CloseLoadingBar()关闭加载框。 特点 加锁控制，防止多个线程同时显示进度框。 可设置提示语并中途修改。 稳定性较好，对于以下非常规调用依然有效。 12345678910private void btn01_Click(object sender, RoutedEventArgs e) { LoadingBar.CloseLoadingBar(); LoadingBar.ShowLoadingbar(); LoadingBar.ShowLoadingbar(); LoadingBar.ShowLoadingbar(); Thread.Sleep(2000); LoadingBar.CloseLoadingBar(); LoadingBar.CloseLoadingBar(); LoadingBar.CloseLoadingBar();}","link":"/post/8acb2158bec2/"},{"title":"行为型设计模式","text":"本文简要介11种类行为型设计模式。 命令（Command） 命令模式，强调将请求封装成对象，进而实现请求排队、记录和撤销等功能。 中介（Mediator） 中介模式，强调在另一个类中集中管理另外几个类的通信。 解释器（Interpreter） 解释器模式，该模式使用场景比较单一，多用于将句子表示成一个抽象语法树，结构与组合模式类似。 使用时会传递一个上下文对象，用于给计算提供数据。 迭代器（Iterator） 迭代器模式，强调为不同的聚合对象提供统一的访问接口，而不暴露聚合对象的内部接口，从而面向用户控制复杂度。 备忘录（Memento） 备忘录模式，强调在不破坏封装性的前提下，捕获一个对象的内部状态，并在外部保存，以便于后期恢复该状态。 职责链（Chain of Responsibility） 职责链模式，强调让一个请求被多个对象处理，这些对象连成一条链。 状态（State） 状态模式，常用于实现状态机，在实现状态子类的动作函数时，会根据状态子类的不同来实现不同的逻辑，并且可以切换状态机的状态，从而驱动状态机的运转。采用这种方式非常容易扩展新的状态。 从类图角度来看，基本和策略模式一样，两者的出发点不一样。 观察者（Observer） 观察者模式，侧重于在一个类的状态发生变化时，同时通知多个类实例。常用于实现“发布-订阅”机制。 策略（Strategy） 策略模式，强调对不同算法的封装，从而实现算法的灵活切换。 其类图类似桥接模式。 模板方法（Template Method） 模板方法模式，在父类的模板方法中编写了某操作的整体流程，但该流程中的某些步骤需要子类延迟实现。该设计模式在框架设计中被广泛使用。 访问者（Visitor） 访问者模式，强调在不改变类的情况下为对象结构中的各元素添加操作。","link":"/post/a86355a608ae/"},{"title":"表格数据链接","text":"CAD提供数据链接的功能，具体来说就是：将一个Excel的某一Sheet与CAD的某一表格关联起来。从而实现Excel表格转CAD表格的操作。 本文封装该接口。 链接Excel表格并插入CAD 重点在于数据链接的创建和绑定。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static Table InsertExcelSheet0(this Document doc, string filePath, string sheetName, Point3d leftTopPoint, double tableWidth, string layoutName = null){ if (doc == null) return null; Database db = doc.Database; Editor ed = doc.Editor; DataLinkManager dataLinkManager = db.DataLinkManager; const string dataLinkName = &quot;从Excel导入表格&quot;; ObjectId dataLinkId = dataLinkManager.GetDataLink(dataLinkName); if (dataLinkId != ObjectId.Null) dataLinkManager.RemoveDataLink(dataLinkId); DataLink dataLink = new DataLink(); dataLink.DataAdapterId = &quot;AcExcel&quot;; dataLink.Name = dataLinkName; dataLink.Description = &quot;Excel&quot;; dataLink.ConnectionString = filePath + &quot;!&quot; + sheetName; dataLinkId = dataLinkManager.AddDataLink(dataLink); Table table = null; using (Transaction transaction = db.TransactionManager.StartTransaction()) { BlockTable bt = transaction.GetObject(db.BlockTableId, OpenMode.ForRead) as BlockTable; ObjectId spaceId = ObjectId.Null; if (layoutName == null) spaceId = bt[BlockTableRecord.ModelSpace]; else { spaceId = GetLayoutIdByName(db, layoutName); if (spaceId == ObjectId.Null) return null; } BlockTableRecord btr = transaction.GetObject(spaceId, OpenMode.ForWrite) as BlockTableRecord; transaction.AddNewlyCreatedDBObject(dataLink, true); table = new Table(); table.TableStyle = db.Tablestyle; table.Position = leftTopPoint; table.Cells[0, 0].DataLink = dataLinkId; table.GenerateLayout(); btr.AppendEntity(table); transaction.AddNewlyCreatedDBObject(table, true); table.Width = tableWidth; table.Height = 1; transaction.Commit(); } ed.Regen(); return table;} 插入链接表格并修改其文字样式 要修改链接表格的样式，必须先炸开表格再进行修改。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void InsertExcelSheetIntoCAD(this Document doc, string filePath, string sheetName, Point3d insertPoint, double tableWidth,out double tableHeight,string fontStyleName = &quot;Standard&quot;, int textColorIndex = 3, int lineColorIndex = 3, string layoutName = null){ tableHeight = 0.0; Database db = doc.Database; var table = doc.InsertExcelSheet0(filePath, sheetName, insertPoint, tableWidth, layoutName); if (table == null) return; var tablebox = table.GeometricExtents; tableHeight = tablebox.MaxPoint.Y - tablebox.MinPoint.Y; var styleId = db.GetTextStyleIdByName(fontStyleName, out double textSize, out double widthFactor); if (styleId == ObjectId.Null) return; using (Transaction transaction = doc.TransactionManager.StartTransaction()) { DBObjectCollection objs = new DBObjectCollection(); table.Explode(objs); List&lt;Entity&gt; entities = new List&lt;Entity&gt;(); foreach (DBObject obj in objs) { if (obj is Entity) { var entity = (Entity)obj; if (entity is MText mText) { DBObjectCollection childObjs = new DBObjectCollection(); mText.Explode(childObjs); foreach (var childObj in childObjs) { if (childObj is DBText dbtext) { dbtext.TextString = dbtext.TextString.Trim(); dbtext.TextStyleId = styleId; dbtext.ColorIndex = textColorIndex; entities.Add(dbtext); } } } else { entity.ColorIndex = lineColorIndex; entities.Add(entity); } } } DwgPainter.DeleteEntity(db, table.ObjectId); DwgPainter.AddEntities(db, entities, layoutName); transaction.Commit(); }}","link":"/post/5d12cbe34b74/"},{"title":"计算机网络之数据加密、报文完整性、端点鉴别","text":"A发送信息给B，站在不同角度直观来看，对本次信息传递有三点要求： A确定信息只有B接收：采用数据加密实现机密性 B确定接收的信息是A发送的：端点鉴别 A、B确定信息传送过程中没有被篡改：报文完整性 技术源于现实需求，从现实需求出发思考技术的意义和组成，是深刻理解技术的起点。个人认为，认识这一点甚至比简单掌握技术内容本身更加重要。 数据加密 数据加密一般采用对称加密方式，计算量较小，但是对称密钥需要通过公开加密密钥进行传输 报文完整性 &amp; 端点鉴别 端点鉴别采用公开加密密钥 加密 &amp; 报文完整性 &amp; 端点鉴别 公式表示法 A将信息m传递给B： Ks(KA−(H(m))+m)+KB+(Ks)K_s(K_A^-(H(m))+m)+K_B^+(K_s) Ks​(KA−​(H(m))+m)+KB+​(Ks​) B收到信息后进行解密操作： KB−:KsKs:KA−(H(m))+mKA+:H(m)H:H(m)K_B^-:K_s\\\\ K_s:K_A^-(H(m))+m\\\\ K_A^+:H(m)\\\\ H:H(m) KB−​:Ks​Ks​:KA−​(H(m))+mKA+​:H(m)H:H(m) 比较：计算的H(m)H(m)H(m)与接收的H(m)H(m)H(m)对比，两者不一致则传输过程有误，但无法判断哪个环节出现问题。","link":"/post/60b99d8095df/"},{"title":"设计模式——类图汇总","text":"设计模式种类繁多，且许多模式之间存在相似之处，要想熟练掌握并在实际项目中灵活运用，需要在实际项目中不断总结。 本着“从少到多，由多变少”的学习原则，我认为应该以类图为核心，做到三点：①观察类图能快速识别模式；②能在大脑中熟练描绘各种模式的类图；③结合类图，理解设计模式的结构特点和解决问题的思路。 所以，本文集中列举各种设计模式的类图，方便随时回顾理解。 创建型 结构型 行为型","link":"/post/b93ba3b72d36/"},{"title":"设计模式——概览","text":"除了功能和性能外，可维护性也是软件开发关注的一大重点，因为任何有价值的软件系统都处于不断迭代的过程中，迭代就意味着变化，例如功能扩展、系统移植等等。而软件开发成本巨大，如何应对变化就成了一门大学问。 设计模式就是为了应对变化，它是面向对象软件设计的精髓，每一种设计模式都描述了在我们周围不断重复出现的问题以及解决该类问题的最佳方案。 虽然大多数书本上只讲解典型的23种设计模式，但设计模式作为工程经验的产物绝对是不断发展变化的。 本系列文章以设计模式的类图为核心，随着项目经验的丰富，将为每种设计模式逐步添加案例分析和使用心得分享。 基本要素 模式名 问题 解决方案：如何设计类或对象的结构来解决问题。 效果：设计模式在控制变化上起到的作用。 怎么学 每一种设计模式应对的典型场景。 每一种设计模式的类图。 每一种设计模式的代码实现关键点。 23种设计模式 记忆顺口溜： 共筹建元旦（工抽建原单） 世代想组装外桥（适代享组装外桥） 命中介叠被子，壮观虐魔方（命中解迭备职，状观略模访）","link":"/post/bd00c564b4cf/"},{"title":"跨图形实体拷贝","text":"当需要将外部DWG图纸中的某些内容拷贝到当前图形时，可以在后台加载DWG，进而从后台数据库中拷贝对象。 本文提供一个示例。 将外部图纸的所有实体拷贝到当前图形 12345678910111213141516171819202122232425262728293031public static bool CopyAllEntity(this Document destinationDoc, string sourceDwgPath, bool isReplace = false){ Database curdb = destinationDoc.Database; using (Database db = new Database(false, true)) { db.ReadDwgFile(sourceDwgPath, FileShare.ReadWrite, true, null); Autodesk.AutoCAD.DatabaseServices.TransactionManager tm = db.TransactionManager; ObjectIdCollection blockIds = new ObjectIdCollection(); using (Transaction tran = tm.StartTransaction()) { BlockTable bt = (BlockTable)tm.GetObject(db.BlockTableId, OpenMode.ForRead, false); BlockTableRecord btr = (BlockTableRecord)tm.GetObject(bt[BlockTableRecord.ModelSpace], OpenMode.ForRead, false); foreach (ObjectId btrId in btr) blockIds.Add(btrId); tran.Commit(); } using (DocumentLock docLock = destinationDoc.LockDocument()) { using (Transaction trans = destinationDoc.TransactionManager.StartTransaction()) { IdMapping mapping = new IdMapping(); BlockTable bt2 = (BlockTable)trans.GetObject(curdb.BlockTableId, OpenMode.ForWrite, false); DuplicateRecordCloning cloning = isReplace ? DuplicateRecordCloning.Replace : DuplicateRecordCloning.Ignore; db.WblockCloneObjects(blockIds, bt2[BlockTableRecord.ModelSpace], mapping, cloning, false); trans.Commit(); } } } return true;}","link":"/post/5a9ab3ef4cc8/"},{"title":"高中毕业十年感悟","text":"人生如逆旅，我等皆行人，从前的我现在的他，现在的我未来的他，《高中毕业十年感悟》一篇，真实所想！ 光阴似箭、日月如梭，2012年入学的那天距离我已如此遥远，早已不记得具体日期。爸爸很早就预约了一辆黄色出租车，在妈妈的目送下，我们拖拉扛拽着几大包行李，风尘仆仆赶赴依畔在东湖旁边的武汉大学。半路下起了瓢泼大雨，为那次旅途增加了很大难度，也让我记忆更加深刻。从那天起，我开启了自己的大学生涯，现在猛然想起，惊讶地意识到我已走过整整十年！十年短暂，如白驹过隙；十年漫长，世界变化翻天覆地，个人心智也被深刻重塑。 近期，本科班长联系我们，让大家结合这十年经历，简单写写关于学习、学校、工作或者行业的感想。特此以“事后诸葛亮”的角度总结一篇《高中毕业十年感想》，希望于己于人能有所启发！ 当年懵懂的90后少年也即将迈向自己的三十岁，在此期间经历了读研、实习、工作等阶段，听了很多、见了很多、想了很多，关于学习、成长和人生的某些想法也悄然发生了变化。 一、想清楚自己究竟想做什么 大学专业分科旨在培养顶尖的专业技术人才，要想达到这个目的，专业的教育引导和学生的自主探索两者缺一不可，然而后者往往极度匮乏，原因在于不热爱，学生只是延续高中喂养式学习模式，安排学什么就学什么，没有联系未来职业生涯思考当下的学习意义。因此，步入大学，在学好专业知识的前提下，在思想上要尽可能突破专业的局限，多了解其他专业的特点，多了解不同职业和工作的性质，多交流、多思考、多反省，不断提升自己选择的能力。如果对某一领域知识的热忱如同小孩看到玩具一样两眼放光，那极有可能就是兴趣所在，那么就深入学习，相信自己通过自学能成为高手。本科短暂，人生漫长，找准目标非常重要，保持热爱，追寻内心，无需太过谨慎以致盲从。 二、没有什么知识技能是高不可攀的，通过自我学习可以成为专业高手 专业分科往往造成学生对其他领域过度敬畏，以致于避而远之，其实各学科之间本没有如此鲜明的界限，例如，当前结构设计十分依赖结构分析软件，结构分析软件以有限元、力学理论为基础，结合计算机图形学、软件工程等计算机技术编制而成。结构工程学生可以致力于结构理论的学习研究，也可以致力于计算软件的开发研究，两者都能做出成绩，关键看兴趣所在。任何一门学科，核心课程不超过五门，能否成为专家关键看热爱、规划和行动。所以，想学习某一技能，找准目标，马上制定计划付出行动！ 三、永葆积极乐观的态度，不要失去活力 网络上有许多消极词汇，比如“社畜”、“躺平”之类；也时常爆出诸如“博士压力过大轻生”之类的新闻；更蔓延着年轻人错失时代红利、生存困难的负面情绪。社会现象是复杂的，形成原因种种，我们不能仅看表面人云亦云。我们需要做的就是找到自己的热爱所在，不断提升自己，在工作中萃取快乐，享受工作，享受生活。即使遇到挫折遇到迷茫，也要有苏东坡“竹杖芒鞋轻胜马，谁怕，一蓑烟雨任平生”的豁达！ 2019年1月29日（南方小年）游高中母校","link":"/post/940353d8c30a/"},{"title":"黄石两日游","text":"生活在高楼林立、车水马龙、熙熙攘攘的都市里，心态不免焦躁，脚步不免急促。趁着春节假期，沐浴着久违的暖阳，踏着轻快的小黄车穿梭在大街小巷，看老人悠闲垂钓，看顽童欢乐嬉戏，看湖面波光粼粼，看远山层峦叠嶂……内心感到无比宁静舒适！ 泥土路上枯草点缀，水泥台阶上斑痕累累，向行人诉说着四季轮回万物枯荣、光阴飞逝岁月悠长，贴近大自然总能感受到它的亲切和博大。迈着不断变得沉重的双腿向山顶进发，汗水湿润了额头也不愿减缓步伐，登临山顶，眺望远处，内心敞亮而豁达。 放缓生活的节奏，置身于朴实的大自然，感受它的无穷魅力，我们的精神将更加富有！ 黄石简介 地理位置 湖北东南部，长江中游南岸，总面积4583平方千米，截至2022年末常住人口244.4万。 东北临长江与黄冈隔江相望，东南与江西九江接壤，西南与咸宁为邻，西靠武汉、鄂州，北接鄂州。 行政区划 1、民国三十四年（1945年）8月15日，日本投降，国民党大冶县政府接管，复置石灰窑和黄石港两镇，隶属于大冶县。 2、民国三十七年（1948年），石灰窑和黄石港两镇合并为石黄镇，隶属于大冶县。 3、1949年5月15日，中国人民解放军解放大冶县；同年6月9日，成立大冶县人民政府；同年6月12日，“武汉市军事管制委员会石灰窑工业特区特派员办事处”成立，不久设置“湖北大冶特区办事处”，直属中原临时人民政府；同年9月29日，划石黄镇、铁麓等乡成立“湖北省大冶工矿特区人民政府”。 4、1950年6月16日，湖北省人民政府以鄂民政特字第104号文，向中南军政委员会请求，将石黄工矿区改组为市，定名“黄石市”。同年8月21日，湖北省辖黄石市正式成立。 5、1952年6月，大冶县划归黄冈专署管辖。 6、1959年1月26日，大冶县从黄冈地区划出，改属黄石市；同年12月，撤销大冶县建制，并入黄石市。 7、1962年6月1日，恢复大冶县建制，仍属黄石市。 8、1979年，黄石正式设立黄石港、石灰窑、下陆、铁山4个县级市辖区。 9、1995年1月1日，大冶正式建市。 10、1996年12月2日，国务院批准阳新县从咸宁地区划归黄石市。 11、2001年12月16日，石灰窑区更名为西塞山区。 城市文化 市树：香樟树 市花：石榴花 荣誉：“2018年国家森林城市”等 特产：印子粑、松花皮蛋、黄石港饼、灵溪豆豉、金柯辣椒 国家4A级旅游景区：黄石国家矿山公园、雷山风景区、东方山风景区、仙岛湖风景区、龙凤山旅游景区 主要高校：湖北师范大学、湖北理工学院 著名湖泊：大冶湖、磁湖、保安湖、网湖、仙岛湖（荆楚第一奇湖）等 2个国家湿地公园：保安湖、莲花湖 6个省级森林公园：大众山、黄荆山、东方山、七峰山、大王山、雷山 2个省级名胜风景区：磁湖、雷山 4个省级自然保护小区：黄坪山、大王山、白水汤、朱婆湖 矿产：“百里黄金地、江南聚宝盆”，历史上，黄石因其丰富的煤、铁、铜、钴、金、锶、铅、锌、硅灰石等矿藏，成为中华民族青铜文化的发祥地。一个多世纪前，湖广总督张之洞在这里创办汉冶萍公司，一批钢铁、水泥、煤炭企业随之诞生，拉开了近代中国民族工业的序幕。新中国成立后，黄石成为我国重要的原材料工业基地，被誉为“江南明珠”。几千年生生不息的矿冶之火，铸造了黄石“矿冶文明之都”的辉煌，也使其走到了“矿竭城衰”的边缘。2009年3月，黄石市被批准为全国第二批资源枯竭城市转型试点。（来源：《推进资源枯竭型城市转型》） 大众山森林公园 江滩","link":"/post/a451db441e0a/"}],"tags":[],"categories":[{"name":"【工程】","slug":"【工程】","link":"/categories/%E3%80%90%E5%B7%A5%E7%A8%8B%E3%80%91/"},{"name":"C++&#x2F;C#混合编程","slug":"【工程】/C-C-混合编程","link":"/categories/%E3%80%90%E5%B7%A5%E7%A8%8B%E3%80%91/C-C-%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"},{"name":"CAD二次开发","slug":"【工程】/CAD二次开发","link":"/categories/%E3%80%90%E5%B7%A5%E7%A8%8B%E3%80%91/CAD%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"name":"C&#x2F;C++","slug":"【工程】/C-C","link":"/categories/%E3%80%90%E5%B7%A5%E7%A8%8B%E3%80%91/C-C/"},{"name":"实用工具","slug":"【工程】/实用工具","link":"/categories/%E3%80%90%E5%B7%A5%E7%A8%8B%E3%80%91/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"WPF","slug":"【工程】/WPF","link":"/categories/%E3%80%90%E5%B7%A5%E7%A8%8B%E3%80%91/WPF/"},{"name":"【架构】","slug":"【架构】","link":"/categories/%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91/"},{"name":"【底层】","slug":"【底层】","link":"/categories/%E3%80%90%E5%BA%95%E5%B1%82%E3%80%91/"},{"name":"NET&#x2F;C#","slug":"【工程】/NET-C","link":"/categories/%E3%80%90%E5%B7%A5%E7%A8%8B%E3%80%91/NET-C/"},{"name":"wxWidgets","slug":"【工程】/wxWidgets","link":"/categories/%E3%80%90%E5%B7%A5%E7%A8%8B%E3%80%91/wxWidgets/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"【算法】","slug":"【算法】","link":"/categories/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91/"},{"name":"软件设计","slug":"【架构】/软件设计","link":"/categories/%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"},{"name":"设计模式","slug":"【架构】/设计模式","link":"/categories/%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Windows系统编程","slug":"【底层】/Windows系统编程","link":"/categories/%E3%80%90%E5%BA%95%E5%B1%82%E3%80%91/Windows%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"},{"name":"计算机网络","slug":"【底层】/计算机网络","link":"/categories/%E3%80%90%E5%BA%95%E5%B1%82%E3%80%91/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"计算几何","slug":"【算法】/计算几何","link":"/categories/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"数据结构与算法","slug":"【算法】/数据结构与算法","link":"/categories/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"pages":[{"title":"","text":"博主 始于土木，逐梦计科，因为热爱，所以无悔！ 我是李浩，武汉大学本科，同济大学硕士，结构工程专业。 目前主要从事工程领域软件开发工作，对底层技术、算法设计、系统架构感兴趣。 搭建个人博客，督促自己进行归纳总结，如果分享的文章对他人能有一点点启发，那就再好不过了。 论文 李浩，超高结构混合减振系统抗震集成优化设计，上海：同济大学，2019.（硕士学位论文） 刘素梅, 徐礼华, 池寅, 李浩. 混凝土结构基本原理教学方法创新与实践[J]. 高等建筑教育, 2017, 26(6):4. Xin ZHAO, Hao LI. Life Cycle Cost Assessment of Integrated Structure-Viscous Damper System for Tall Buildings. IABSE Conference Stockholm 2016[C]. International Association for Bridge and Structural Engineering, Stockholm, 2016.（EI检索） Xin ZHAO, Hao LI. Constant Incremental Sensitivity Analysis Method in Optimal Design for Tall Building Structures. MMS Conference Guangzhou 2016[C]. 2016 International Conference on Mechanics and Materials Sciences, Guangzhou, 2016. Xin ZHAO, Hao LI. Constant Incremental Sensitivity Analysis Based Optimal Design for Tall Building under Overall Stability Constraint. EASEC-15 Conference Xian 2017[C]. The Fifteenth East Asia-Pacific Conference on Structural Engineering &amp; Construction, Xian, 2017. 赵昕, 李浩, 秦朗. 周期与层间位移角双约束条件下超高层结构优化设计方法[J]. 建筑结构学报，2018，39(1)：129-135. （EI 检索） 赵昕, 杜冰洁, 李浩. 超高层建筑黏滞阻尼器及屈曲约束支撑混合减振结构系统集成优化设计[J]. 建筑结构学报, 2020(3):11. (EI检索) Bingjie DU, Xin ZHAO, Hao LI. Multiperformance optimization design of a hybrid vibration mitigation system for super high‐ rise buildings to improve earthquake resistance[J]. The Structural Design of Tall and Special Buildings, 2020(4). (SCI检索) 李浩. 空间网架网壳结构Revit参数化建模方法[J]. 铁路技术创新, 2020(3):7. 李浩. 勘察报告表格和文本信息提取算法研究[J]. 铁道技术标准, 2024(3):6. 软著 武汉大学组卷系统. 登记号：2018SR642992.（独立开发） 矩形方钢管混凝土柱-钢结构设计约束分析软件. 登记号：2018SR657509.（独立开发） 基于虚拟VD模型的装备最优布置软件. 登记号：2018SR657908.（独立开发） 基于支撑应力分析的BRB最优布置软件. 登记号：2018SR657896.（独立开发） 网架网壳Revit参数化建模插件V1.0. 登记号：2020SR1022316.（独立开发） 梁柱批量设计软件V1.0. 登记号：2020SR1100419.（独立开发）","link":"/about/index.html"},{"title":"","text":"结构工程 陈学伟的博客 崔济东的博客-JiDong Cui’s Blog 结构小站 计算机技术博客 Fabrice Bellard’s Home Page 酷壳 – CoolShell.cn 阮一峰的个人网站 – Ruan YiFeng’s Personal Website 廖雪峰的官方网站 刘建平Pinard – 博客园 (cnblogs.com) DevBlogs – Microsoft Developer Blogs Learn C++ – Skill up with our free tutorials (learncpp.com) Advanced C#.NET Online Training Program – Dot Net Tutorials 当然我在扯淡 (yinwang.org) 小林coding (xiaolincoding.com) Yanyan’s Wiki (jyywiki.cn) 开发文档 技术文档 | Microsoft Learn .NET API browser | Microsoft Learn cppreference.com scikit-learn: machine learning in Python — scikit-learn 1.4.1 documentation PyTorch OpenCV: OpenCV modules wxWidgets: Documentation MDN Web Docs (mozilla.org) NSIS Users Manual (sourceforge.io) (chez (chez scheme)) Racket (racket-lang.org) Unified Modeling Language (UML) Build smaller, faster, and more secure desktop applications with a web frontend | Tauri Apps NASM - The Netwide Assembler Makefile教程和示例指南 (foofun.cn) Welcome to Linux From Scratch! CMake Reference Documentation — CMake 3.30.0-rc3 Documentation The Ninja build system (ninja-build.org) AutoCAD 2021 Developer and ObjectARX 帮助 | Autodesk","link":"/link/index.html"}]}